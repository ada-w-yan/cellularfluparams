// This file was automatically generated by odin.
// Do not edit by hand as changes will be lost.
#include <R.h>
#include <Rmath.h>
#include <Rinternals.h>
#include <R_ext/Rdynload.h>
#include <stdbool.h>

// Collect together all the parameters and transient memory
// required to run the model in a struct.
typedef struct model_mock_yield_pars {
  int odin_use_dde;
  double V_0;
  double c;
  double initial_V;
} model_mock_yield_pars;
model_mock_yield_pars* model_mock_yield_get_pointer(SEXP model_mock_yield_ptr, int closed_error);
SEXP model_mock_yield_set_user(model_mock_yield_pars *model_mock_yield_p, SEXP user);
typedef struct model_teiv_stages_dual_linear_p_pars {
  int odin_use_dde;
  int n_L;
  int n_I;
  double beta;
  double beta_inf;
  double beta_tot;
  double k1;
  double delta;
  double p_inf;
  double p_tot;
  double c_inf;
  double c_tot;
  double T_0;
  double V_inf_0;
  double V_tot_0;
  double initial_T1;
  double initial_V_inf;
  double initial_V_tot;
  int dim_L;
  double *initial_L;
  int offset_L;
  int dim_I;
  double *initial_I;
  int offset_I;
  int dim_L_0;
  double *L_0;
  int dim_I_0;
  double *I_0;
  int dim_I_scale_vec;
  double *I_scale_vec;
  int dim;
} model_teiv_stages_dual_linear_p_pars;
model_teiv_stages_dual_linear_p_pars* model_teiv_stages_dual_linear_p_get_pointer(SEXP model_teiv_stages_dual_linear_p_ptr, int closed_error);
SEXP model_teiv_stages_dual_linear_p_set_user(model_teiv_stages_dual_linear_p_pars *model_teiv_stages_dual_linear_p_p, SEXP user);
typedef struct model_teiv_stages_dual_pars {
  int odin_use_dde;
  int n_L;
  int n_I;
  double beta;
  double beta_inf;
  double beta_tot;
  double k1;
  double delta;
  double p_inf;
  double p_tot;
  double c_inf;
  double c_tot;
  double T_0;
  double V_inf_0;
  double V_tot_0;
  double initial_T1;
  double initial_V_inf;
  double initial_V_tot;
  int dim_L;
  double *initial_L;
  int offset_L;
  int dim_I;
  double *initial_I;
  int offset_I;
  int dim_L_0;
  double *L_0;
  int dim_I_0;
  double *I_0;
  int dim;
} model_teiv_stages_dual_pars;
model_teiv_stages_dual_pars* model_teiv_stages_dual_get_pointer(SEXP model_teiv_stages_dual_ptr, int closed_error);
SEXP model_teiv_stages_dual_set_user(model_teiv_stages_dual_pars *model_teiv_stages_dual_p, SEXP user);
typedef struct model_teiv_stages_gen_G_inoculum_pars {
  int odin_use_dde;
  int n_L;
  int n_I;
  double beta;
  double beta_inf;
  double delta;
  double p_inf;
  double c_inf;
  double T_0;
  double V_inf_0;
  int G;
  double k1;
  int dim_L;
  int dim_L_1;
  int dim_L_2;
  double *initial_L;
  int offset_L;
  int dim_I;
  int dim_I_1;
  int dim_I_2;
  double *initial_I;
  int offset_I;
  int dim_V;
  double *initial_V;
  int offset_V;
  int dim_W;
  double *initial_W;
  int offset_W;
  int dim_L_0;
  int dim_L_0_1;
  int dim_L_0_2;
  double *L_0;
  int dim_I_0;
  int dim_I_0_1;
  int dim_I_0_2;
  double *I_0;
  double initial_T1;
  int dim;
} model_teiv_stages_gen_G_inoculum_pars;
model_teiv_stages_gen_G_inoculum_pars* model_teiv_stages_gen_G_inoculum_get_pointer(SEXP model_teiv_stages_gen_G_inoculum_ptr, int closed_error);
SEXP model_teiv_stages_gen_G_inoculum_set_user(model_teiv_stages_gen_G_inoculum_pars *model_teiv_stages_gen_G_inoculum_p, SEXP user);

SEXP get_ds_pars();
double get_user_double(SEXP user, const char *name, double default_value);
SEXP get_list_element(SEXP list, const char *name);
int get_user_int(SEXP user, const char *name, int default_value);
void get_user_array(SEXP user, const char *name, bool is_real, void *dest, int nd, ...);
SEXP get_user_array_check_rank(SEXP user, const char *name, int nd);
void get_user_array_copy(SEXP el, const char *name, bool is_real, void *dest);
double odin_sum1(double *x, int from_i, int to_i);
void odin_set_dim(SEXP target, int nd, ...);
double odin_sum2(double *x, int from_i, int to_i, int from_j, int to_j, int dim_x_1);

// Create the pointer; this will establish the struct, allocate
// memory for things that are constant size, and initialize
// constant variables
static void model_mock_yield_finalize(SEXP model_mock_yield_ptr);
SEXP model_mock_yield_create(SEXP user, SEXP odin_use_dde) {
  model_mock_yield_pars *model_mock_yield_p = (model_mock_yield_pars*) Calloc(1, model_mock_yield_pars);
  model_mock_yield_p->V_0 = NA_REAL;
  model_mock_yield_p->c = NA_REAL;
  SEXP model_mock_yield_ptr = PROTECT(R_MakeExternalPtr(model_mock_yield_p, R_NilValue, R_NilValue));
  R_RegisterCFinalizer(model_mock_yield_ptr, model_mock_yield_finalize);
  model_mock_yield_set_user(model_mock_yield_p, user);
  model_mock_yield_p->odin_use_dde = INTEGER(odin_use_dde)[0];
  UNPROTECT(1);
  return model_mock_yield_ptr;
}

// Set user-supplied parameter values.
SEXP model_mock_yield_set_user(model_mock_yield_pars *model_mock_yield_p, SEXP user) {
  model_mock_yield_p->V_0 = get_user_double(user, "V_0", model_mock_yield_p->V_0);
  model_mock_yield_p->c = get_user_double(user, "c", model_mock_yield_p->c);
  model_mock_yield_p->initial_V = model_mock_yield_p->V_0;
  return R_NilValue;
}
// Wrapper around this for use from R.
SEXP r_model_mock_yield_set_user(SEXP model_mock_yield_ptr, SEXP user) {
  model_mock_yield_pars *model_mock_yield_p = model_mock_yield_get_pointer(model_mock_yield_ptr, 1);
  model_mock_yield_set_user(model_mock_yield_p, user);
  return R_NilValue;
}

// Arrange to free all memory we have allocated
// This is called by R automatically when the pointer is
// garbage collected (i.e., when all objects holding the pointer
// go out of scope
void model_mock_yield_finalize(SEXP model_mock_yield_ptr) {
  model_mock_yield_pars *model_mock_yield_p = model_mock_yield_get_pointer(model_mock_yield_ptr, 0);
  if (model_mock_yield_ptr) {
    Free(model_mock_yield_p);
    R_ClearExternalPtr(model_mock_yield_ptr);
  }
}

SEXP model_mock_yield_initialise(SEXP model_mock_yield_ptr, SEXP t_ptr) {
  model_mock_yield_pars *model_mock_yield_p = model_mock_yield_get_pointer(model_mock_yield_ptr, 1);
  SEXP state = PROTECT(allocVector(REALSXP, 1));
  REAL(state)[0] = model_mock_yield_p->initial_V;
  UNPROTECT(1);
  return state;
}

SEXP model_mock_yield_set_initial(SEXP model_mock_yield_ptr, SEXP t_ptr, SEXP state_ptr) {
  return R_NilValue;
}

void model_mock_yield_deriv(model_mock_yield_pars *model_mock_yield_p, double t, double *state, double *dstatedt, double *output) {
  double V = state[0];
  dstatedt[0] = -model_mock_yield_p->c * V;
}

// deSolve interface
// Global variable set on initmod, as per deSolve design
static model_mock_yield_pars *model_mock_yield_p;
void model_mock_yield_initmod_ds(void(* odeparms) (int *, double *)) {
  DL_FUNC get_deSolve_gparms = R_GetCCallable("deSolve", "get_deSolve_gparms");
  model_mock_yield_p = model_mock_yield_get_pointer(get_deSolve_gparms(), 1);
}
void model_mock_yield_deriv_ds(int *neq, double *t, double *state,
                               double *dstatedt, double *output, int *np) {
  model_mock_yield_deriv(model_mock_yield_p, *t, state, dstatedt, output);
}

// dde interface
void model_mock_yield_deriv_dde(size_t n_eq, double t, double *state,
                                 double *dstatedt, void *model_mock_yield_p) {
  model_mock_yield_deriv((model_mock_yield_pars*)model_mock_yield_p, t, state, dstatedt, NULL);
}

SEXP model_mock_yield_deriv_r(SEXP model_mock_yield_ptr, SEXP t, SEXP state) {
  SEXP dstatedt = PROTECT(allocVector(REALSXP, LENGTH(state)));
  model_mock_yield_pars *model_mock_yield_p = model_mock_yield_get_pointer(model_mock_yield_ptr, 1);
  double *output = NULL;
  model_mock_yield_deriv(model_mock_yield_p, REAL(t)[0], REAL(state), REAL(dstatedt), output);
  UNPROTECT(1);
  return dstatedt;
}

// Translate all elements in the struct back to R
// This will mostly be useful for debugging.
SEXP model_mock_yield_contents(SEXP model_mock_yield_ptr) {
  model_mock_yield_pars *model_mock_yield_p = model_mock_yield_get_pointer(model_mock_yield_ptr, 1);
  SEXP state = PROTECT(allocVector(VECSXP, 4));
  SET_VECTOR_ELT(state, 0, ScalarInteger(model_mock_yield_p->odin_use_dde));
  SET_VECTOR_ELT(state, 1, ScalarReal(model_mock_yield_p->V_0));
  SET_VECTOR_ELT(state, 2, ScalarReal(model_mock_yield_p->c));
  SET_VECTOR_ELT(state, 3, ScalarReal(model_mock_yield_p->initial_V));
  SEXP state_names = PROTECT(allocVector(STRSXP, 4));
  SET_STRING_ELT(state_names, 0, mkChar("odin_use_dde"));
  SET_STRING_ELT(state_names, 1, mkChar("V_0"));
  SET_STRING_ELT(state_names, 2, mkChar("c"));
  SET_STRING_ELT(state_names, 3, mkChar("initial_V"));
  setAttrib(state, R_NamesSymbol, state_names);
  UNPROTECT(2);
  return state;
}

// Report back to R information on variable ordering
// The reported information includes position and length of each
// variable, from which offset, etc, can be worked out.
SEXP model_mock_yield_variable_order(SEXP model_mock_yield_ptr) {
  SEXP state_len = PROTECT(allocVector(VECSXP, 1));
  SEXP state_names = PROTECT(allocVector(STRSXP, 1));
  SET_VECTOR_ELT(state_len, 0, R_NilValue);
  SET_STRING_ELT(state_names, 0, mkChar("V"));
  setAttrib(state_len, R_NamesSymbol, state_names);
  UNPROTECT(2);
  return state_len;
}

model_mock_yield_pars* model_mock_yield_get_pointer(SEXP model_mock_yield_ptr, int closed_error) {
  model_mock_yield_pars *model_mock_yield_p = NULL;
  if (TYPEOF(model_mock_yield_ptr) != EXTPTRSXP) {
    Rf_error("Expected an external pointer");
  }
  model_mock_yield_p = (model_mock_yield_pars*) R_ExternalPtrAddr(model_mock_yield_ptr);
  if (!model_mock_yield_p && closed_error) {
    Rf_error("Pointer has been invalidated");
  }
  return model_mock_yield_p;
}
// Create the pointer; this will establish the struct, allocate
// memory for things that are constant size, and initialize
// constant variables
static void model_teiv_stages_dual_linear_p_finalize(SEXP model_teiv_stages_dual_linear_p_ptr);
SEXP model_teiv_stages_dual_linear_p_create(SEXP user, SEXP odin_use_dde) {
  model_teiv_stages_dual_linear_p_pars *model_teiv_stages_dual_linear_p_p = (model_teiv_stages_dual_linear_p_pars*) Calloc(1, model_teiv_stages_dual_linear_p_pars);
  model_teiv_stages_dual_linear_p_p->n_L = NA_INTEGER;
  model_teiv_stages_dual_linear_p_p->n_I = NA_INTEGER;
  model_teiv_stages_dual_linear_p_p->beta = NA_REAL;
  model_teiv_stages_dual_linear_p_p->beta_inf = NA_REAL;
  model_teiv_stages_dual_linear_p_p->beta_tot = NA_REAL;
  model_teiv_stages_dual_linear_p_p->k1 = NA_REAL;
  model_teiv_stages_dual_linear_p_p->delta = NA_REAL;
  model_teiv_stages_dual_linear_p_p->p_inf = NA_REAL;
  model_teiv_stages_dual_linear_p_p->p_tot = NA_REAL;
  model_teiv_stages_dual_linear_p_p->c_inf = NA_REAL;
  model_teiv_stages_dual_linear_p_p->c_tot = NA_REAL;
  model_teiv_stages_dual_linear_p_p->T_0 = NA_REAL;
  model_teiv_stages_dual_linear_p_p->V_inf_0 = NA_REAL;
  model_teiv_stages_dual_linear_p_p->V_tot_0 = NA_REAL;
  model_teiv_stages_dual_linear_p_p->initial_L = NULL;
  model_teiv_stages_dual_linear_p_p->initial_I = NULL;
  model_teiv_stages_dual_linear_p_p->L_0 = NULL;
  model_teiv_stages_dual_linear_p_p->I_0 = NULL;
  model_teiv_stages_dual_linear_p_p->I_scale_vec = NULL;
  SEXP model_teiv_stages_dual_linear_p_ptr = PROTECT(R_MakeExternalPtr(model_teiv_stages_dual_linear_p_p, R_NilValue, R_NilValue));
  R_RegisterCFinalizer(model_teiv_stages_dual_linear_p_ptr, model_teiv_stages_dual_linear_p_finalize);
  model_teiv_stages_dual_linear_p_set_user(model_teiv_stages_dual_linear_p_p, user);
  model_teiv_stages_dual_linear_p_p->odin_use_dde = INTEGER(odin_use_dde)[0];
  UNPROTECT(1);
  return model_teiv_stages_dual_linear_p_ptr;
}

// Set user-supplied parameter values.
SEXP model_teiv_stages_dual_linear_p_set_user(model_teiv_stages_dual_linear_p_pars *model_teiv_stages_dual_linear_p_p, SEXP user) {
  model_teiv_stages_dual_linear_p_p->n_L = get_user_int(user, "n_L", model_teiv_stages_dual_linear_p_p->n_L);
  model_teiv_stages_dual_linear_p_p->n_I = get_user_int(user, "n_I", model_teiv_stages_dual_linear_p_p->n_I);
  model_teiv_stages_dual_linear_p_p->beta = get_user_double(user, "beta", model_teiv_stages_dual_linear_p_p->beta);
  model_teiv_stages_dual_linear_p_p->beta_inf = get_user_double(user, "beta_inf", model_teiv_stages_dual_linear_p_p->beta_inf);
  model_teiv_stages_dual_linear_p_p->beta_tot = get_user_double(user, "beta_tot", model_teiv_stages_dual_linear_p_p->beta_tot);
  model_teiv_stages_dual_linear_p_p->k1 = get_user_double(user, "k1", model_teiv_stages_dual_linear_p_p->k1);
  model_teiv_stages_dual_linear_p_p->delta = get_user_double(user, "delta", model_teiv_stages_dual_linear_p_p->delta);
  model_teiv_stages_dual_linear_p_p->p_inf = get_user_double(user, "p_inf", model_teiv_stages_dual_linear_p_p->p_inf);
  model_teiv_stages_dual_linear_p_p->p_tot = get_user_double(user, "p_tot", model_teiv_stages_dual_linear_p_p->p_tot);
  model_teiv_stages_dual_linear_p_p->c_inf = get_user_double(user, "c_inf", model_teiv_stages_dual_linear_p_p->c_inf);
  model_teiv_stages_dual_linear_p_p->c_tot = get_user_double(user, "c_tot", model_teiv_stages_dual_linear_p_p->c_tot);
  model_teiv_stages_dual_linear_p_p->T_0 = get_user_double(user, "T_0", model_teiv_stages_dual_linear_p_p->T_0);
  model_teiv_stages_dual_linear_p_p->V_inf_0 = get_user_double(user, "V_inf_0", model_teiv_stages_dual_linear_p_p->V_inf_0);
  model_teiv_stages_dual_linear_p_p->V_tot_0 = get_user_double(user, "V_tot_0", model_teiv_stages_dual_linear_p_p->V_tot_0);
  model_teiv_stages_dual_linear_p_p->initial_T1 = model_teiv_stages_dual_linear_p_p->T_0;
  model_teiv_stages_dual_linear_p_p->initial_V_inf = model_teiv_stages_dual_linear_p_p->V_inf_0;
  model_teiv_stages_dual_linear_p_p->initial_V_tot = model_teiv_stages_dual_linear_p_p->V_tot_0;
  Free(model_teiv_stages_dual_linear_p_p->initial_L);
  model_teiv_stages_dual_linear_p_p->dim_L = model_teiv_stages_dual_linear_p_p->n_L;
  model_teiv_stages_dual_linear_p_p->initial_L = (double*) Calloc(model_teiv_stages_dual_linear_p_p->dim_L, double);
  model_teiv_stages_dual_linear_p_p->offset_L = 3;
  Free(model_teiv_stages_dual_linear_p_p->initial_I);
  model_teiv_stages_dual_linear_p_p->dim_I = model_teiv_stages_dual_linear_p_p->n_I;
  model_teiv_stages_dual_linear_p_p->initial_I = (double*) Calloc(model_teiv_stages_dual_linear_p_p->dim_I, double);
  model_teiv_stages_dual_linear_p_p->offset_I = 3 + model_teiv_stages_dual_linear_p_p->dim_L;
  Free(model_teiv_stages_dual_linear_p_p->L_0);
  model_teiv_stages_dual_linear_p_p->dim_L_0 = model_teiv_stages_dual_linear_p_p->n_L;
  model_teiv_stages_dual_linear_p_p->L_0 = (double*) Calloc(model_teiv_stages_dual_linear_p_p->dim_L_0, double);
  Free(model_teiv_stages_dual_linear_p_p->I_0);
  model_teiv_stages_dual_linear_p_p->dim_I_0 = model_teiv_stages_dual_linear_p_p->n_I;
  model_teiv_stages_dual_linear_p_p->I_0 = (double*) Calloc(model_teiv_stages_dual_linear_p_p->dim_I_0, double);
  Free(model_teiv_stages_dual_linear_p_p->I_scale_vec);
  model_teiv_stages_dual_linear_p_p->dim_I_scale_vec = model_teiv_stages_dual_linear_p_p->n_I;
  model_teiv_stages_dual_linear_p_p->I_scale_vec = (double*) Calloc(model_teiv_stages_dual_linear_p_p->dim_I_scale_vec, double);
  get_user_array(user, "L_0", true, model_teiv_stages_dual_linear_p_p->L_0, 1, model_teiv_stages_dual_linear_p_p->dim_L_0);
  for (int i = 0; i < model_teiv_stages_dual_linear_p_p->n_L; ++i) {
    model_teiv_stages_dual_linear_p_p->initial_L[i] = model_teiv_stages_dual_linear_p_p->L_0[i];
  }
  get_user_array(user, "I_0", true, model_teiv_stages_dual_linear_p_p->I_0, 1, model_teiv_stages_dual_linear_p_p->dim_I_0);
  for (int i = 0; i < model_teiv_stages_dual_linear_p_p->n_I; ++i) {
    model_teiv_stages_dual_linear_p_p->initial_I[i] = model_teiv_stages_dual_linear_p_p->I_0[i];
  }
  model_teiv_stages_dual_linear_p_p->dim = model_teiv_stages_dual_linear_p_p->offset_I + model_teiv_stages_dual_linear_p_p->dim_I;
  return R_NilValue;
}
// Wrapper around this for use from R.
SEXP r_model_teiv_stages_dual_linear_p_set_user(SEXP model_teiv_stages_dual_linear_p_ptr, SEXP user) {
  model_teiv_stages_dual_linear_p_pars *model_teiv_stages_dual_linear_p_p = model_teiv_stages_dual_linear_p_get_pointer(model_teiv_stages_dual_linear_p_ptr, 1);
  model_teiv_stages_dual_linear_p_set_user(model_teiv_stages_dual_linear_p_p, user);
  return R_NilValue;
}

// Arrange to free all memory we have allocated
// This is called by R automatically when the pointer is
// garbage collected (i.e., when all objects holding the pointer
// go out of scope
void model_teiv_stages_dual_linear_p_finalize(SEXP model_teiv_stages_dual_linear_p_ptr) {
  model_teiv_stages_dual_linear_p_pars *model_teiv_stages_dual_linear_p_p = model_teiv_stages_dual_linear_p_get_pointer(model_teiv_stages_dual_linear_p_ptr, 0);
  if (model_teiv_stages_dual_linear_p_ptr) {
    Free(model_teiv_stages_dual_linear_p_p->initial_L);
    Free(model_teiv_stages_dual_linear_p_p->initial_I);
    Free(model_teiv_stages_dual_linear_p_p->L_0);
    Free(model_teiv_stages_dual_linear_p_p->I_0);
    Free(model_teiv_stages_dual_linear_p_p->I_scale_vec);
    Free(model_teiv_stages_dual_linear_p_p);
    R_ClearExternalPtr(model_teiv_stages_dual_linear_p_ptr);
  }
}

SEXP model_teiv_stages_dual_linear_p_initialise(SEXP model_teiv_stages_dual_linear_p_ptr, SEXP t_ptr) {
  model_teiv_stages_dual_linear_p_pars *model_teiv_stages_dual_linear_p_p = model_teiv_stages_dual_linear_p_get_pointer(model_teiv_stages_dual_linear_p_ptr, 1);
  SEXP state = PROTECT(allocVector(REALSXP, model_teiv_stages_dual_linear_p_p->dim));
  REAL(state)[0] = model_teiv_stages_dual_linear_p_p->initial_T1;
  REAL(state)[1] = model_teiv_stages_dual_linear_p_p->initial_V_inf;
  REAL(state)[2] = model_teiv_stages_dual_linear_p_p->initial_V_tot;
  memcpy(REAL(state) + 3, model_teiv_stages_dual_linear_p_p->initial_L, model_teiv_stages_dual_linear_p_p->dim_L * sizeof(double));
  memcpy(REAL(state) + model_teiv_stages_dual_linear_p_p->offset_I, model_teiv_stages_dual_linear_p_p->initial_I, model_teiv_stages_dual_linear_p_p->dim_I * sizeof(double));
  UNPROTECT(1);
  return state;
}

SEXP model_teiv_stages_dual_linear_p_set_initial(SEXP model_teiv_stages_dual_linear_p_ptr, SEXP t_ptr, SEXP state_ptr) {
  return R_NilValue;
}

void model_teiv_stages_dual_linear_p_deriv(model_teiv_stages_dual_linear_p_pars *model_teiv_stages_dual_linear_p_p, double t, double *state, double *dstatedt, double *output) {
  double T1 = state[0];
  double V_inf = state[1];
  double V_tot = state[2];
  double *L = state + 3;
  double *I = state + model_teiv_stages_dual_linear_p_p->offset_I;
  double *deriv_L = dstatedt + 3;
  double *deriv_I = dstatedt + model_teiv_stages_dual_linear_p_p->offset_I;
  dstatedt[0] = -fmax(0, model_teiv_stages_dual_linear_p_p->beta * T1 * V_inf);
  {
    int i = 0;
    deriv_L[i] = fmax(0, model_teiv_stages_dual_linear_p_p->beta * T1 * V_inf) - fmax(0, model_teiv_stages_dual_linear_p_p->k1 * model_teiv_stages_dual_linear_p_p->n_L * L[i]);
  }
  for (int i = 1; i < model_teiv_stages_dual_linear_p_p->n_L; ++i) {
    deriv_L[i] = fmax(0, model_teiv_stages_dual_linear_p_p->k1 * model_teiv_stages_dual_linear_p_p->n_L * L[i - 1]) - fmax(0, model_teiv_stages_dual_linear_p_p->k1 * model_teiv_stages_dual_linear_p_p->n_L * L[i]);
  }
  {
    int i = 0;
    deriv_I[i] = fmax(0, model_teiv_stages_dual_linear_p_p->k1 * model_teiv_stages_dual_linear_p_p->n_L * L[model_teiv_stages_dual_linear_p_p->n_L - 1]) - fmax(0, model_teiv_stages_dual_linear_p_p->delta * model_teiv_stages_dual_linear_p_p->n_I * I[i]);
  }
  for (int i = 1; i < model_teiv_stages_dual_linear_p_p->n_I; ++i) {
    deriv_I[i] = fmax(0, model_teiv_stages_dual_linear_p_p->delta * model_teiv_stages_dual_linear_p_p->n_I * I[i - 1]) - fmax(0, model_teiv_stages_dual_linear_p_p->delta * model_teiv_stages_dual_linear_p_p->n_I * I[i]);
  }
  for (int i = 0; i < model_teiv_stages_dual_linear_p_p->n_I; ++i) {
    model_teiv_stages_dual_linear_p_p->I_scale_vec[i] = (i + 1) / model_teiv_stages_dual_linear_p_p->n_I * I[i];
  }
  dstatedt[1] = fmax(0, model_teiv_stages_dual_linear_p_p->p_inf * odin_sum1(model_teiv_stages_dual_linear_p_p->I_scale_vec, 0, model_teiv_stages_dual_linear_p_p->dim_I_scale_vec - 1)) - fmax(0, model_teiv_stages_dual_linear_p_p->c_inf * V_inf) - fmax(0, model_teiv_stages_dual_linear_p_p->beta_inf * T1 * V_inf);
  dstatedt[2] = fmax(0, model_teiv_stages_dual_linear_p_p->p_tot * odin_sum1(model_teiv_stages_dual_linear_p_p->I_scale_vec, 0, model_teiv_stages_dual_linear_p_p->dim_I_scale_vec - 1)) - fmax(0, model_teiv_stages_dual_linear_p_p->c_tot * V_tot) - fmax(0, model_teiv_stages_dual_linear_p_p->beta_tot * T1 * V_inf);
}

// deSolve interface
// Global variable set on initmod, as per deSolve design
static model_teiv_stages_dual_linear_p_pars *model_teiv_stages_dual_linear_p_p;
void model_teiv_stages_dual_linear_p_initmod_ds(void(* odeparms) (int *, double *)) {
  DL_FUNC get_deSolve_gparms = R_GetCCallable("deSolve", "get_deSolve_gparms");
  model_teiv_stages_dual_linear_p_p = model_teiv_stages_dual_linear_p_get_pointer(get_deSolve_gparms(), 1);
}
void model_teiv_stages_dual_linear_p_deriv_ds(int *neq, double *t, double *state,
                                              double *dstatedt, double *output, int *np) {
  model_teiv_stages_dual_linear_p_deriv(model_teiv_stages_dual_linear_p_p, *t, state, dstatedt, output);
}

// dde interface
void model_teiv_stages_dual_linear_p_deriv_dde(size_t n_eq, double t, double *state,
                                                double *dstatedt, void *model_teiv_stages_dual_linear_p_p) {
  model_teiv_stages_dual_linear_p_deriv((model_teiv_stages_dual_linear_p_pars*)model_teiv_stages_dual_linear_p_p, t, state, dstatedt, NULL);
}

SEXP model_teiv_stages_dual_linear_p_deriv_r(SEXP model_teiv_stages_dual_linear_p_ptr, SEXP t, SEXP state) {
  SEXP dstatedt = PROTECT(allocVector(REALSXP, LENGTH(state)));
  model_teiv_stages_dual_linear_p_pars *model_teiv_stages_dual_linear_p_p = model_teiv_stages_dual_linear_p_get_pointer(model_teiv_stages_dual_linear_p_ptr, 1);
  double *output = NULL;
  model_teiv_stages_dual_linear_p_deriv(model_teiv_stages_dual_linear_p_p, REAL(t)[0], REAL(state), REAL(dstatedt), output);
  UNPROTECT(1);
  return dstatedt;
}

// Translate all elements in the struct back to R
// This will mostly be useful for debugging.
SEXP model_teiv_stages_dual_linear_p_contents(SEXP model_teiv_stages_dual_linear_p_ptr) {
  model_teiv_stages_dual_linear_p_pars *model_teiv_stages_dual_linear_p_p = model_teiv_stages_dual_linear_p_get_pointer(model_teiv_stages_dual_linear_p_ptr, 1);
  SEXP state = PROTECT(allocVector(VECSXP, 31));
  SET_VECTOR_ELT(state, 0, ScalarInteger(model_teiv_stages_dual_linear_p_p->odin_use_dde));
  SET_VECTOR_ELT(state, 1, ScalarInteger(model_teiv_stages_dual_linear_p_p->n_L));
  SET_VECTOR_ELT(state, 2, ScalarInteger(model_teiv_stages_dual_linear_p_p->n_I));
  SET_VECTOR_ELT(state, 3, ScalarReal(model_teiv_stages_dual_linear_p_p->beta));
  SET_VECTOR_ELT(state, 4, ScalarReal(model_teiv_stages_dual_linear_p_p->beta_inf));
  SET_VECTOR_ELT(state, 5, ScalarReal(model_teiv_stages_dual_linear_p_p->beta_tot));
  SET_VECTOR_ELT(state, 6, ScalarReal(model_teiv_stages_dual_linear_p_p->k1));
  SET_VECTOR_ELT(state, 7, ScalarReal(model_teiv_stages_dual_linear_p_p->delta));
  SET_VECTOR_ELT(state, 8, ScalarReal(model_teiv_stages_dual_linear_p_p->p_inf));
  SET_VECTOR_ELT(state, 9, ScalarReal(model_teiv_stages_dual_linear_p_p->p_tot));
  SET_VECTOR_ELT(state, 10, ScalarReal(model_teiv_stages_dual_linear_p_p->c_inf));
  SET_VECTOR_ELT(state, 11, ScalarReal(model_teiv_stages_dual_linear_p_p->c_tot));
  SET_VECTOR_ELT(state, 12, ScalarReal(model_teiv_stages_dual_linear_p_p->T_0));
  SET_VECTOR_ELT(state, 13, ScalarReal(model_teiv_stages_dual_linear_p_p->V_inf_0));
  SET_VECTOR_ELT(state, 14, ScalarReal(model_teiv_stages_dual_linear_p_p->V_tot_0));
  SET_VECTOR_ELT(state, 15, ScalarReal(model_teiv_stages_dual_linear_p_p->initial_T1));
  SET_VECTOR_ELT(state, 16, ScalarReal(model_teiv_stages_dual_linear_p_p->initial_V_inf));
  SET_VECTOR_ELT(state, 17, ScalarReal(model_teiv_stages_dual_linear_p_p->initial_V_tot));
  SET_VECTOR_ELT(state, 18, ScalarInteger(model_teiv_stages_dual_linear_p_p->dim_L));
  SET_VECTOR_ELT(state, 19, allocVector(REALSXP, model_teiv_stages_dual_linear_p_p->dim_L));
  memcpy(REAL(VECTOR_ELT(state, 19)), model_teiv_stages_dual_linear_p_p->initial_L, model_teiv_stages_dual_linear_p_p->dim_L * sizeof(double));
  SET_VECTOR_ELT(state, 20, ScalarInteger(model_teiv_stages_dual_linear_p_p->offset_L));
  SET_VECTOR_ELT(state, 21, ScalarInteger(model_teiv_stages_dual_linear_p_p->dim_I));
  SET_VECTOR_ELT(state, 22, allocVector(REALSXP, model_teiv_stages_dual_linear_p_p->dim_I));
  memcpy(REAL(VECTOR_ELT(state, 22)), model_teiv_stages_dual_linear_p_p->initial_I, model_teiv_stages_dual_linear_p_p->dim_I * sizeof(double));
  SET_VECTOR_ELT(state, 23, ScalarInteger(model_teiv_stages_dual_linear_p_p->offset_I));
  SET_VECTOR_ELT(state, 24, ScalarInteger(model_teiv_stages_dual_linear_p_p->dim_L_0));
  SET_VECTOR_ELT(state, 25, allocVector(REALSXP, model_teiv_stages_dual_linear_p_p->dim_L_0));
  memcpy(REAL(VECTOR_ELT(state, 25)), model_teiv_stages_dual_linear_p_p->L_0, model_teiv_stages_dual_linear_p_p->dim_L_0 * sizeof(double));
  SET_VECTOR_ELT(state, 26, ScalarInteger(model_teiv_stages_dual_linear_p_p->dim_I_0));
  SET_VECTOR_ELT(state, 27, allocVector(REALSXP, model_teiv_stages_dual_linear_p_p->dim_I_0));
  memcpy(REAL(VECTOR_ELT(state, 27)), model_teiv_stages_dual_linear_p_p->I_0, model_teiv_stages_dual_linear_p_p->dim_I_0 * sizeof(double));
  SET_VECTOR_ELT(state, 28, ScalarInteger(model_teiv_stages_dual_linear_p_p->dim_I_scale_vec));
  SET_VECTOR_ELT(state, 29, allocVector(REALSXP, model_teiv_stages_dual_linear_p_p->dim_I_scale_vec));
  memcpy(REAL(VECTOR_ELT(state, 29)), model_teiv_stages_dual_linear_p_p->I_scale_vec, model_teiv_stages_dual_linear_p_p->dim_I_scale_vec * sizeof(double));
  SET_VECTOR_ELT(state, 30, ScalarInteger(model_teiv_stages_dual_linear_p_p->dim));
  SEXP state_names = PROTECT(allocVector(STRSXP, 31));
  SET_STRING_ELT(state_names, 0, mkChar("odin_use_dde"));
  SET_STRING_ELT(state_names, 1, mkChar("n_L"));
  SET_STRING_ELT(state_names, 2, mkChar("n_I"));
  SET_STRING_ELT(state_names, 3, mkChar("beta"));
  SET_STRING_ELT(state_names, 4, mkChar("beta_inf"));
  SET_STRING_ELT(state_names, 5, mkChar("beta_tot"));
  SET_STRING_ELT(state_names, 6, mkChar("k1"));
  SET_STRING_ELT(state_names, 7, mkChar("delta"));
  SET_STRING_ELT(state_names, 8, mkChar("p_inf"));
  SET_STRING_ELT(state_names, 9, mkChar("p_tot"));
  SET_STRING_ELT(state_names, 10, mkChar("c_inf"));
  SET_STRING_ELT(state_names, 11, mkChar("c_tot"));
  SET_STRING_ELT(state_names, 12, mkChar("T_0"));
  SET_STRING_ELT(state_names, 13, mkChar("V_inf_0"));
  SET_STRING_ELT(state_names, 14, mkChar("V_tot_0"));
  SET_STRING_ELT(state_names, 15, mkChar("initial_T1"));
  SET_STRING_ELT(state_names, 16, mkChar("initial_V_inf"));
  SET_STRING_ELT(state_names, 17, mkChar("initial_V_tot"));
  SET_STRING_ELT(state_names, 18, mkChar("dim_L"));
  SET_STRING_ELT(state_names, 19, mkChar("initial_L"));
  SET_STRING_ELT(state_names, 20, mkChar("offset_L"));
  SET_STRING_ELT(state_names, 21, mkChar("dim_I"));
  SET_STRING_ELT(state_names, 22, mkChar("initial_I"));
  SET_STRING_ELT(state_names, 23, mkChar("offset_I"));
  SET_STRING_ELT(state_names, 24, mkChar("dim_L_0"));
  SET_STRING_ELT(state_names, 25, mkChar("L_0"));
  SET_STRING_ELT(state_names, 26, mkChar("dim_I_0"));
  SET_STRING_ELT(state_names, 27, mkChar("I_0"));
  SET_STRING_ELT(state_names, 28, mkChar("dim_I_scale_vec"));
  SET_STRING_ELT(state_names, 29, mkChar("I_scale_vec"));
  SET_STRING_ELT(state_names, 30, mkChar("dim"));
  setAttrib(state, R_NamesSymbol, state_names);
  UNPROTECT(2);
  return state;
}

// Report back to R information on variable ordering
// The reported information includes position and length of each
// variable, from which offset, etc, can be worked out.
SEXP model_teiv_stages_dual_linear_p_variable_order(SEXP model_teiv_stages_dual_linear_p_ptr) {
  model_teiv_stages_dual_linear_p_pars *model_teiv_stages_dual_linear_p_p = model_teiv_stages_dual_linear_p_get_pointer(model_teiv_stages_dual_linear_p_ptr, 1);
  SEXP state_len = PROTECT(allocVector(VECSXP, 5));
  SEXP state_names = PROTECT(allocVector(STRSXP, 5));
  SET_VECTOR_ELT(state_len, 0, R_NilValue);
  SET_STRING_ELT(state_names, 0, mkChar("T1"));
  SET_VECTOR_ELT(state_len, 1, R_NilValue);
  SET_STRING_ELT(state_names, 1, mkChar("V_inf"));
  SET_VECTOR_ELT(state_len, 2, R_NilValue);
  SET_STRING_ELT(state_names, 2, mkChar("V_tot"));
  SET_VECTOR_ELT(state_len, 3, ScalarInteger(model_teiv_stages_dual_linear_p_p->dim_L));
  SET_STRING_ELT(state_names, 3, mkChar("L"));
  SET_VECTOR_ELT(state_len, 4, ScalarInteger(model_teiv_stages_dual_linear_p_p->dim_I));
  SET_STRING_ELT(state_names, 4, mkChar("I"));
  setAttrib(state_len, R_NamesSymbol, state_names);
  UNPROTECT(2);
  return state_len;
}

model_teiv_stages_dual_linear_p_pars* model_teiv_stages_dual_linear_p_get_pointer(SEXP model_teiv_stages_dual_linear_p_ptr, int closed_error) {
  model_teiv_stages_dual_linear_p_pars *model_teiv_stages_dual_linear_p_p = NULL;
  if (TYPEOF(model_teiv_stages_dual_linear_p_ptr) != EXTPTRSXP) {
    Rf_error("Expected an external pointer");
  }
  model_teiv_stages_dual_linear_p_p = (model_teiv_stages_dual_linear_p_pars*) R_ExternalPtrAddr(model_teiv_stages_dual_linear_p_ptr);
  if (!model_teiv_stages_dual_linear_p_p && closed_error) {
    Rf_error("Pointer has been invalidated");
  }
  return model_teiv_stages_dual_linear_p_p;
}
// Create the pointer; this will establish the struct, allocate
// memory for things that are constant size, and initialize
// constant variables
static void model_teiv_stages_dual_finalize(SEXP model_teiv_stages_dual_ptr);
SEXP model_teiv_stages_dual_create(SEXP user, SEXP odin_use_dde) {
  model_teiv_stages_dual_pars *model_teiv_stages_dual_p = (model_teiv_stages_dual_pars*) Calloc(1, model_teiv_stages_dual_pars);
  model_teiv_stages_dual_p->n_L = NA_INTEGER;
  model_teiv_stages_dual_p->n_I = NA_INTEGER;
  model_teiv_stages_dual_p->beta = NA_REAL;
  model_teiv_stages_dual_p->beta_inf = NA_REAL;
  model_teiv_stages_dual_p->beta_tot = NA_REAL;
  model_teiv_stages_dual_p->k1 = NA_REAL;
  model_teiv_stages_dual_p->delta = NA_REAL;
  model_teiv_stages_dual_p->p_inf = NA_REAL;
  model_teiv_stages_dual_p->p_tot = NA_REAL;
  model_teiv_stages_dual_p->c_inf = NA_REAL;
  model_teiv_stages_dual_p->c_tot = NA_REAL;
  model_teiv_stages_dual_p->T_0 = NA_REAL;
  model_teiv_stages_dual_p->V_inf_0 = NA_REAL;
  model_teiv_stages_dual_p->V_tot_0 = NA_REAL;
  model_teiv_stages_dual_p->initial_L = NULL;
  model_teiv_stages_dual_p->initial_I = NULL;
  model_teiv_stages_dual_p->L_0 = NULL;
  model_teiv_stages_dual_p->I_0 = NULL;
  SEXP model_teiv_stages_dual_ptr = PROTECT(R_MakeExternalPtr(model_teiv_stages_dual_p, R_NilValue, R_NilValue));
  R_RegisterCFinalizer(model_teiv_stages_dual_ptr, model_teiv_stages_dual_finalize);
  model_teiv_stages_dual_set_user(model_teiv_stages_dual_p, user);
  model_teiv_stages_dual_p->odin_use_dde = INTEGER(odin_use_dde)[0];
  UNPROTECT(1);
  return model_teiv_stages_dual_ptr;
}

// Set user-supplied parameter values.
SEXP model_teiv_stages_dual_set_user(model_teiv_stages_dual_pars *model_teiv_stages_dual_p, SEXP user) {
  model_teiv_stages_dual_p->n_L = get_user_int(user, "n_L", model_teiv_stages_dual_p->n_L);
  model_teiv_stages_dual_p->n_I = get_user_int(user, "n_I", model_teiv_stages_dual_p->n_I);
  model_teiv_stages_dual_p->beta = get_user_double(user, "beta", model_teiv_stages_dual_p->beta);
  model_teiv_stages_dual_p->beta_inf = get_user_double(user, "beta_inf", model_teiv_stages_dual_p->beta_inf);
  model_teiv_stages_dual_p->beta_tot = get_user_double(user, "beta_tot", model_teiv_stages_dual_p->beta_tot);
  model_teiv_stages_dual_p->k1 = get_user_double(user, "k1", model_teiv_stages_dual_p->k1);
  model_teiv_stages_dual_p->delta = get_user_double(user, "delta", model_teiv_stages_dual_p->delta);
  model_teiv_stages_dual_p->p_inf = get_user_double(user, "p_inf", model_teiv_stages_dual_p->p_inf);
  model_teiv_stages_dual_p->p_tot = get_user_double(user, "p_tot", model_teiv_stages_dual_p->p_tot);
  model_teiv_stages_dual_p->c_inf = get_user_double(user, "c_inf", model_teiv_stages_dual_p->c_inf);
  model_teiv_stages_dual_p->c_tot = get_user_double(user, "c_tot", model_teiv_stages_dual_p->c_tot);
  model_teiv_stages_dual_p->T_0 = get_user_double(user, "T_0", model_teiv_stages_dual_p->T_0);
  model_teiv_stages_dual_p->V_inf_0 = get_user_double(user, "V_inf_0", model_teiv_stages_dual_p->V_inf_0);
  model_teiv_stages_dual_p->V_tot_0 = get_user_double(user, "V_tot_0", model_teiv_stages_dual_p->V_tot_0);
  model_teiv_stages_dual_p->initial_T1 = model_teiv_stages_dual_p->T_0;
  model_teiv_stages_dual_p->initial_V_inf = model_teiv_stages_dual_p->V_inf_0;
  model_teiv_stages_dual_p->initial_V_tot = model_teiv_stages_dual_p->V_tot_0;
  Free(model_teiv_stages_dual_p->initial_L);
  model_teiv_stages_dual_p->dim_L = model_teiv_stages_dual_p->n_L;
  model_teiv_stages_dual_p->initial_L = (double*) Calloc(model_teiv_stages_dual_p->dim_L, double);
  model_teiv_stages_dual_p->offset_L = 3;
  Free(model_teiv_stages_dual_p->initial_I);
  model_teiv_stages_dual_p->dim_I = model_teiv_stages_dual_p->n_I;
  model_teiv_stages_dual_p->initial_I = (double*) Calloc(model_teiv_stages_dual_p->dim_I, double);
  model_teiv_stages_dual_p->offset_I = 3 + model_teiv_stages_dual_p->dim_L;
  Free(model_teiv_stages_dual_p->L_0);
  model_teiv_stages_dual_p->dim_L_0 = model_teiv_stages_dual_p->n_L;
  model_teiv_stages_dual_p->L_0 = (double*) Calloc(model_teiv_stages_dual_p->dim_L_0, double);
  Free(model_teiv_stages_dual_p->I_0);
  model_teiv_stages_dual_p->dim_I_0 = model_teiv_stages_dual_p->n_I;
  model_teiv_stages_dual_p->I_0 = (double*) Calloc(model_teiv_stages_dual_p->dim_I_0, double);
  get_user_array(user, "L_0", true, model_teiv_stages_dual_p->L_0, 1, model_teiv_stages_dual_p->dim_L_0);
  for (int i = 0; i < model_teiv_stages_dual_p->n_L; ++i) {
    model_teiv_stages_dual_p->initial_L[i] = model_teiv_stages_dual_p->L_0[i];
  }
  get_user_array(user, "I_0", true, model_teiv_stages_dual_p->I_0, 1, model_teiv_stages_dual_p->dim_I_0);
  for (int i = 0; i < model_teiv_stages_dual_p->n_I; ++i) {
    model_teiv_stages_dual_p->initial_I[i] = model_teiv_stages_dual_p->I_0[i];
  }
  model_teiv_stages_dual_p->dim = model_teiv_stages_dual_p->offset_I + model_teiv_stages_dual_p->dim_I;
  return R_NilValue;
}
// Wrapper around this for use from R.
SEXP r_model_teiv_stages_dual_set_user(SEXP model_teiv_stages_dual_ptr, SEXP user) {
  model_teiv_stages_dual_pars *model_teiv_stages_dual_p = model_teiv_stages_dual_get_pointer(model_teiv_stages_dual_ptr, 1);
  model_teiv_stages_dual_set_user(model_teiv_stages_dual_p, user);
  return R_NilValue;
}

// Arrange to free all memory we have allocated
// This is called by R automatically when the pointer is
// garbage collected (i.e., when all objects holding the pointer
// go out of scope
void model_teiv_stages_dual_finalize(SEXP model_teiv_stages_dual_ptr) {
  model_teiv_stages_dual_pars *model_teiv_stages_dual_p = model_teiv_stages_dual_get_pointer(model_teiv_stages_dual_ptr, 0);
  if (model_teiv_stages_dual_ptr) {
    Free(model_teiv_stages_dual_p->initial_L);
    Free(model_teiv_stages_dual_p->initial_I);
    Free(model_teiv_stages_dual_p->L_0);
    Free(model_teiv_stages_dual_p->I_0);
    Free(model_teiv_stages_dual_p);
    R_ClearExternalPtr(model_teiv_stages_dual_ptr);
  }
}

SEXP model_teiv_stages_dual_initialise(SEXP model_teiv_stages_dual_ptr, SEXP t_ptr) {
  model_teiv_stages_dual_pars *model_teiv_stages_dual_p = model_teiv_stages_dual_get_pointer(model_teiv_stages_dual_ptr, 1);
  SEXP state = PROTECT(allocVector(REALSXP, model_teiv_stages_dual_p->dim));
  REAL(state)[0] = model_teiv_stages_dual_p->initial_T1;
  REAL(state)[1] = model_teiv_stages_dual_p->initial_V_inf;
  REAL(state)[2] = model_teiv_stages_dual_p->initial_V_tot;
  memcpy(REAL(state) + 3, model_teiv_stages_dual_p->initial_L, model_teiv_stages_dual_p->dim_L * sizeof(double));
  memcpy(REAL(state) + model_teiv_stages_dual_p->offset_I, model_teiv_stages_dual_p->initial_I, model_teiv_stages_dual_p->dim_I * sizeof(double));
  UNPROTECT(1);
  return state;
}

SEXP model_teiv_stages_dual_set_initial(SEXP model_teiv_stages_dual_ptr, SEXP t_ptr, SEXP state_ptr) {
  return R_NilValue;
}

void model_teiv_stages_dual_deriv(model_teiv_stages_dual_pars *model_teiv_stages_dual_p, double t, double *state, double *dstatedt, double *output) {
  double T1 = state[0];
  double V_inf = state[1];
  double V_tot = state[2];
  double *L = state + 3;
  double *I = state + model_teiv_stages_dual_p->offset_I;
  double *deriv_L = dstatedt + 3;
  double *deriv_I = dstatedt + model_teiv_stages_dual_p->offset_I;
  dstatedt[0] = -fmax(0, model_teiv_stages_dual_p->beta * T1 * V_inf);
  dstatedt[1] = fmax(0, model_teiv_stages_dual_p->p_inf * odin_sum1(I, 0, model_teiv_stages_dual_p->dim_I - 1)) - fmax(0, model_teiv_stages_dual_p->c_inf * V_inf) - fmax(0, model_teiv_stages_dual_p->beta_inf * T1 * V_inf);
  dstatedt[2] = fmax(0, model_teiv_stages_dual_p->p_tot * odin_sum1(I, 0, model_teiv_stages_dual_p->dim_I - 1)) - fmax(0, model_teiv_stages_dual_p->c_tot * V_tot) - fmax(0, model_teiv_stages_dual_p->beta_tot * T1 * V_inf);
  {
    int i = 0;
    deriv_L[i] = fmax(0, model_teiv_stages_dual_p->beta * T1 * V_inf) - fmax(0, model_teiv_stages_dual_p->k1 * model_teiv_stages_dual_p->n_L * L[i]);
  }
  for (int i = 1; i < model_teiv_stages_dual_p->n_L; ++i) {
    deriv_L[i] = fmax(0, model_teiv_stages_dual_p->k1 * model_teiv_stages_dual_p->n_L * L[i - 1]) - fmax(0, model_teiv_stages_dual_p->k1 * model_teiv_stages_dual_p->n_L * L[i]);
  }
  {
    int i = 0;
    deriv_I[i] = fmax(0, model_teiv_stages_dual_p->k1 * model_teiv_stages_dual_p->n_L * L[model_teiv_stages_dual_p->n_L - 1]) - fmax(0, model_teiv_stages_dual_p->delta * model_teiv_stages_dual_p->n_I * I[i]);
  }
  for (int i = 1; i < model_teiv_stages_dual_p->n_I; ++i) {
    deriv_I[i] = fmax(0, model_teiv_stages_dual_p->delta * model_teiv_stages_dual_p->n_I * I[i - 1]) - fmax(0, model_teiv_stages_dual_p->delta * model_teiv_stages_dual_p->n_I * I[i]);
  }
}

// deSolve interface
// Global variable set on initmod, as per deSolve design
static model_teiv_stages_dual_pars *model_teiv_stages_dual_p;
void model_teiv_stages_dual_initmod_ds(void(* odeparms) (int *, double *)) {
  DL_FUNC get_deSolve_gparms = R_GetCCallable("deSolve", "get_deSolve_gparms");
  model_teiv_stages_dual_p = model_teiv_stages_dual_get_pointer(get_deSolve_gparms(), 1);
}
void model_teiv_stages_dual_deriv_ds(int *neq, double *t, double *state,
                                     double *dstatedt, double *output, int *np) {
  model_teiv_stages_dual_deriv(model_teiv_stages_dual_p, *t, state, dstatedt, output);
}

// dde interface
void model_teiv_stages_dual_deriv_dde(size_t n_eq, double t, double *state,
                                       double *dstatedt, void *model_teiv_stages_dual_p) {
  model_teiv_stages_dual_deriv((model_teiv_stages_dual_pars*)model_teiv_stages_dual_p, t, state, dstatedt, NULL);
}

SEXP model_teiv_stages_dual_deriv_r(SEXP model_teiv_stages_dual_ptr, SEXP t, SEXP state) {
  SEXP dstatedt = PROTECT(allocVector(REALSXP, LENGTH(state)));
  model_teiv_stages_dual_pars *model_teiv_stages_dual_p = model_teiv_stages_dual_get_pointer(model_teiv_stages_dual_ptr, 1);
  double *output = NULL;
  model_teiv_stages_dual_deriv(model_teiv_stages_dual_p, REAL(t)[0], REAL(state), REAL(dstatedt), output);
  UNPROTECT(1);
  return dstatedt;
}

// Translate all elements in the struct back to R
// This will mostly be useful for debugging.
SEXP model_teiv_stages_dual_contents(SEXP model_teiv_stages_dual_ptr) {
  model_teiv_stages_dual_pars *model_teiv_stages_dual_p = model_teiv_stages_dual_get_pointer(model_teiv_stages_dual_ptr, 1);
  SEXP state = PROTECT(allocVector(VECSXP, 29));
  SET_VECTOR_ELT(state, 0, ScalarInteger(model_teiv_stages_dual_p->odin_use_dde));
  SET_VECTOR_ELT(state, 1, ScalarInteger(model_teiv_stages_dual_p->n_L));
  SET_VECTOR_ELT(state, 2, ScalarInteger(model_teiv_stages_dual_p->n_I));
  SET_VECTOR_ELT(state, 3, ScalarReal(model_teiv_stages_dual_p->beta));
  SET_VECTOR_ELT(state, 4, ScalarReal(model_teiv_stages_dual_p->beta_inf));
  SET_VECTOR_ELT(state, 5, ScalarReal(model_teiv_stages_dual_p->beta_tot));
  SET_VECTOR_ELT(state, 6, ScalarReal(model_teiv_stages_dual_p->k1));
  SET_VECTOR_ELT(state, 7, ScalarReal(model_teiv_stages_dual_p->delta));
  SET_VECTOR_ELT(state, 8, ScalarReal(model_teiv_stages_dual_p->p_inf));
  SET_VECTOR_ELT(state, 9, ScalarReal(model_teiv_stages_dual_p->p_tot));
  SET_VECTOR_ELT(state, 10, ScalarReal(model_teiv_stages_dual_p->c_inf));
  SET_VECTOR_ELT(state, 11, ScalarReal(model_teiv_stages_dual_p->c_tot));
  SET_VECTOR_ELT(state, 12, ScalarReal(model_teiv_stages_dual_p->T_0));
  SET_VECTOR_ELT(state, 13, ScalarReal(model_teiv_stages_dual_p->V_inf_0));
  SET_VECTOR_ELT(state, 14, ScalarReal(model_teiv_stages_dual_p->V_tot_0));
  SET_VECTOR_ELT(state, 15, ScalarReal(model_teiv_stages_dual_p->initial_T1));
  SET_VECTOR_ELT(state, 16, ScalarReal(model_teiv_stages_dual_p->initial_V_inf));
  SET_VECTOR_ELT(state, 17, ScalarReal(model_teiv_stages_dual_p->initial_V_tot));
  SET_VECTOR_ELT(state, 18, ScalarInteger(model_teiv_stages_dual_p->dim_L));
  SET_VECTOR_ELT(state, 19, allocVector(REALSXP, model_teiv_stages_dual_p->dim_L));
  memcpy(REAL(VECTOR_ELT(state, 19)), model_teiv_stages_dual_p->initial_L, model_teiv_stages_dual_p->dim_L * sizeof(double));
  SET_VECTOR_ELT(state, 20, ScalarInteger(model_teiv_stages_dual_p->offset_L));
  SET_VECTOR_ELT(state, 21, ScalarInteger(model_teiv_stages_dual_p->dim_I));
  SET_VECTOR_ELT(state, 22, allocVector(REALSXP, model_teiv_stages_dual_p->dim_I));
  memcpy(REAL(VECTOR_ELT(state, 22)), model_teiv_stages_dual_p->initial_I, model_teiv_stages_dual_p->dim_I * sizeof(double));
  SET_VECTOR_ELT(state, 23, ScalarInteger(model_teiv_stages_dual_p->offset_I));
  SET_VECTOR_ELT(state, 24, ScalarInteger(model_teiv_stages_dual_p->dim_L_0));
  SET_VECTOR_ELT(state, 25, allocVector(REALSXP, model_teiv_stages_dual_p->dim_L_0));
  memcpy(REAL(VECTOR_ELT(state, 25)), model_teiv_stages_dual_p->L_0, model_teiv_stages_dual_p->dim_L_0 * sizeof(double));
  SET_VECTOR_ELT(state, 26, ScalarInteger(model_teiv_stages_dual_p->dim_I_0));
  SET_VECTOR_ELT(state, 27, allocVector(REALSXP, model_teiv_stages_dual_p->dim_I_0));
  memcpy(REAL(VECTOR_ELT(state, 27)), model_teiv_stages_dual_p->I_0, model_teiv_stages_dual_p->dim_I_0 * sizeof(double));
  SET_VECTOR_ELT(state, 28, ScalarInteger(model_teiv_stages_dual_p->dim));
  SEXP state_names = PROTECT(allocVector(STRSXP, 29));
  SET_STRING_ELT(state_names, 0, mkChar("odin_use_dde"));
  SET_STRING_ELT(state_names, 1, mkChar("n_L"));
  SET_STRING_ELT(state_names, 2, mkChar("n_I"));
  SET_STRING_ELT(state_names, 3, mkChar("beta"));
  SET_STRING_ELT(state_names, 4, mkChar("beta_inf"));
  SET_STRING_ELT(state_names, 5, mkChar("beta_tot"));
  SET_STRING_ELT(state_names, 6, mkChar("k1"));
  SET_STRING_ELT(state_names, 7, mkChar("delta"));
  SET_STRING_ELT(state_names, 8, mkChar("p_inf"));
  SET_STRING_ELT(state_names, 9, mkChar("p_tot"));
  SET_STRING_ELT(state_names, 10, mkChar("c_inf"));
  SET_STRING_ELT(state_names, 11, mkChar("c_tot"));
  SET_STRING_ELT(state_names, 12, mkChar("T_0"));
  SET_STRING_ELT(state_names, 13, mkChar("V_inf_0"));
  SET_STRING_ELT(state_names, 14, mkChar("V_tot_0"));
  SET_STRING_ELT(state_names, 15, mkChar("initial_T1"));
  SET_STRING_ELT(state_names, 16, mkChar("initial_V_inf"));
  SET_STRING_ELT(state_names, 17, mkChar("initial_V_tot"));
  SET_STRING_ELT(state_names, 18, mkChar("dim_L"));
  SET_STRING_ELT(state_names, 19, mkChar("initial_L"));
  SET_STRING_ELT(state_names, 20, mkChar("offset_L"));
  SET_STRING_ELT(state_names, 21, mkChar("dim_I"));
  SET_STRING_ELT(state_names, 22, mkChar("initial_I"));
  SET_STRING_ELT(state_names, 23, mkChar("offset_I"));
  SET_STRING_ELT(state_names, 24, mkChar("dim_L_0"));
  SET_STRING_ELT(state_names, 25, mkChar("L_0"));
  SET_STRING_ELT(state_names, 26, mkChar("dim_I_0"));
  SET_STRING_ELT(state_names, 27, mkChar("I_0"));
  SET_STRING_ELT(state_names, 28, mkChar("dim"));
  setAttrib(state, R_NamesSymbol, state_names);
  UNPROTECT(2);
  return state;
}

// Report back to R information on variable ordering
// The reported information includes position and length of each
// variable, from which offset, etc, can be worked out.
SEXP model_teiv_stages_dual_variable_order(SEXP model_teiv_stages_dual_ptr) {
  model_teiv_stages_dual_pars *model_teiv_stages_dual_p = model_teiv_stages_dual_get_pointer(model_teiv_stages_dual_ptr, 1);
  SEXP state_len = PROTECT(allocVector(VECSXP, 5));
  SEXP state_names = PROTECT(allocVector(STRSXP, 5));
  SET_VECTOR_ELT(state_len, 0, R_NilValue);
  SET_STRING_ELT(state_names, 0, mkChar("T1"));
  SET_VECTOR_ELT(state_len, 1, R_NilValue);
  SET_STRING_ELT(state_names, 1, mkChar("V_inf"));
  SET_VECTOR_ELT(state_len, 2, R_NilValue);
  SET_STRING_ELT(state_names, 2, mkChar("V_tot"));
  SET_VECTOR_ELT(state_len, 3, ScalarInteger(model_teiv_stages_dual_p->dim_L));
  SET_STRING_ELT(state_names, 3, mkChar("L"));
  SET_VECTOR_ELT(state_len, 4, ScalarInteger(model_teiv_stages_dual_p->dim_I));
  SET_STRING_ELT(state_names, 4, mkChar("I"));
  setAttrib(state_len, R_NamesSymbol, state_names);
  UNPROTECT(2);
  return state_len;
}

model_teiv_stages_dual_pars* model_teiv_stages_dual_get_pointer(SEXP model_teiv_stages_dual_ptr, int closed_error) {
  model_teiv_stages_dual_pars *model_teiv_stages_dual_p = NULL;
  if (TYPEOF(model_teiv_stages_dual_ptr) != EXTPTRSXP) {
    Rf_error("Expected an external pointer");
  }
  model_teiv_stages_dual_p = (model_teiv_stages_dual_pars*) R_ExternalPtrAddr(model_teiv_stages_dual_ptr);
  if (!model_teiv_stages_dual_p && closed_error) {
    Rf_error("Pointer has been invalidated");
  }
  return model_teiv_stages_dual_p;
}
// Create the pointer; this will establish the struct, allocate
// memory for things that are constant size, and initialize
// constant variables
static void model_teiv_stages_gen_G_inoculum_finalize(SEXP model_teiv_stages_gen_G_inoculum_ptr);
SEXP model_teiv_stages_gen_G_inoculum_create(SEXP user, SEXP odin_use_dde) {
  model_teiv_stages_gen_G_inoculum_pars *model_teiv_stages_gen_G_inoculum_p = (model_teiv_stages_gen_G_inoculum_pars*) Calloc(1, model_teiv_stages_gen_G_inoculum_pars);
  model_teiv_stages_gen_G_inoculum_p->n_L = NA_INTEGER;
  model_teiv_stages_gen_G_inoculum_p->n_I = NA_INTEGER;
  model_teiv_stages_gen_G_inoculum_p->beta = NA_REAL;
  model_teiv_stages_gen_G_inoculum_p->beta_inf = NA_REAL;
  model_teiv_stages_gen_G_inoculum_p->delta = NA_REAL;
  model_teiv_stages_gen_G_inoculum_p->p_inf = NA_REAL;
  model_teiv_stages_gen_G_inoculum_p->c_inf = NA_REAL;
  model_teiv_stages_gen_G_inoculum_p->T_0 = NA_REAL;
  model_teiv_stages_gen_G_inoculum_p->V_inf_0 = NA_REAL;
  model_teiv_stages_gen_G_inoculum_p->G = NA_INTEGER;
  model_teiv_stages_gen_G_inoculum_p->k1 = NA_REAL;
  model_teiv_stages_gen_G_inoculum_p->initial_L = NULL;
  model_teiv_stages_gen_G_inoculum_p->initial_I = NULL;
  model_teiv_stages_gen_G_inoculum_p->initial_V = NULL;
  model_teiv_stages_gen_G_inoculum_p->initial_W = NULL;
  model_teiv_stages_gen_G_inoculum_p->L_0 = NULL;
  model_teiv_stages_gen_G_inoculum_p->I_0 = NULL;
  SEXP model_teiv_stages_gen_G_inoculum_ptr = PROTECT(R_MakeExternalPtr(model_teiv_stages_gen_G_inoculum_p, R_NilValue, R_NilValue));
  R_RegisterCFinalizer(model_teiv_stages_gen_G_inoculum_ptr, model_teiv_stages_gen_G_inoculum_finalize);
  model_teiv_stages_gen_G_inoculum_set_user(model_teiv_stages_gen_G_inoculum_p, user);
  model_teiv_stages_gen_G_inoculum_p->odin_use_dde = INTEGER(odin_use_dde)[0];
  UNPROTECT(1);
  return model_teiv_stages_gen_G_inoculum_ptr;
}

// Set user-supplied parameter values.
SEXP model_teiv_stages_gen_G_inoculum_set_user(model_teiv_stages_gen_G_inoculum_pars *model_teiv_stages_gen_G_inoculum_p, SEXP user) {
  model_teiv_stages_gen_G_inoculum_p->n_L = get_user_int(user, "n_L", model_teiv_stages_gen_G_inoculum_p->n_L);
  model_teiv_stages_gen_G_inoculum_p->n_I = get_user_int(user, "n_I", model_teiv_stages_gen_G_inoculum_p->n_I);
  model_teiv_stages_gen_G_inoculum_p->beta = get_user_double(user, "beta", model_teiv_stages_gen_G_inoculum_p->beta);
  model_teiv_stages_gen_G_inoculum_p->beta_inf = get_user_double(user, "beta_inf", model_teiv_stages_gen_G_inoculum_p->beta_inf);
  model_teiv_stages_gen_G_inoculum_p->delta = get_user_double(user, "delta", model_teiv_stages_gen_G_inoculum_p->delta);
  model_teiv_stages_gen_G_inoculum_p->p_inf = get_user_double(user, "p_inf", model_teiv_stages_gen_G_inoculum_p->p_inf);
  model_teiv_stages_gen_G_inoculum_p->c_inf = get_user_double(user, "c_inf", model_teiv_stages_gen_G_inoculum_p->c_inf);
  model_teiv_stages_gen_G_inoculum_p->T_0 = get_user_double(user, "T_0", model_teiv_stages_gen_G_inoculum_p->T_0);
  model_teiv_stages_gen_G_inoculum_p->V_inf_0 = get_user_double(user, "V_inf_0", model_teiv_stages_gen_G_inoculum_p->V_inf_0);
  model_teiv_stages_gen_G_inoculum_p->G = get_user_int(user, "G", model_teiv_stages_gen_G_inoculum_p->G);
  model_teiv_stages_gen_G_inoculum_p->k1 = get_user_double(user, "k1", model_teiv_stages_gen_G_inoculum_p->k1);
  Free(model_teiv_stages_gen_G_inoculum_p->initial_L);
  model_teiv_stages_gen_G_inoculum_p->dim_L_1 = model_teiv_stages_gen_G_inoculum_p->n_L;
  model_teiv_stages_gen_G_inoculum_p->dim_L_2 = model_teiv_stages_gen_G_inoculum_p->G;
  model_teiv_stages_gen_G_inoculum_p->dim_L = model_teiv_stages_gen_G_inoculum_p->dim_L_1 * model_teiv_stages_gen_G_inoculum_p->dim_L_2;
  model_teiv_stages_gen_G_inoculum_p->initial_L = (double*) Calloc(model_teiv_stages_gen_G_inoculum_p->dim_L, double);
  model_teiv_stages_gen_G_inoculum_p->offset_L = 1;
  Free(model_teiv_stages_gen_G_inoculum_p->initial_I);
  model_teiv_stages_gen_G_inoculum_p->dim_I_1 = model_teiv_stages_gen_G_inoculum_p->n_I;
  model_teiv_stages_gen_G_inoculum_p->dim_I_2 = model_teiv_stages_gen_G_inoculum_p->G;
  model_teiv_stages_gen_G_inoculum_p->dim_I = model_teiv_stages_gen_G_inoculum_p->dim_I_1 * model_teiv_stages_gen_G_inoculum_p->dim_I_2;
  model_teiv_stages_gen_G_inoculum_p->initial_I = (double*) Calloc(model_teiv_stages_gen_G_inoculum_p->dim_I, double);
  model_teiv_stages_gen_G_inoculum_p->offset_I = 1 + model_teiv_stages_gen_G_inoculum_p->dim_L;
  Free(model_teiv_stages_gen_G_inoculum_p->initial_V);
  model_teiv_stages_gen_G_inoculum_p->dim_V = model_teiv_stages_gen_G_inoculum_p->G;
  model_teiv_stages_gen_G_inoculum_p->initial_V = (double*) Calloc(model_teiv_stages_gen_G_inoculum_p->dim_V, double);
  model_teiv_stages_gen_G_inoculum_p->offset_V = model_teiv_stages_gen_G_inoculum_p->offset_I + model_teiv_stages_gen_G_inoculum_p->dim_I;
  Free(model_teiv_stages_gen_G_inoculum_p->initial_W);
  model_teiv_stages_gen_G_inoculum_p->dim_W = model_teiv_stages_gen_G_inoculum_p->G;
  model_teiv_stages_gen_G_inoculum_p->initial_W = (double*) Calloc(model_teiv_stages_gen_G_inoculum_p->dim_W, double);
  model_teiv_stages_gen_G_inoculum_p->offset_W = model_teiv_stages_gen_G_inoculum_p->offset_V + model_teiv_stages_gen_G_inoculum_p->dim_V;
  Free(model_teiv_stages_gen_G_inoculum_p->L_0);
  model_teiv_stages_gen_G_inoculum_p->dim_L_0_1 = model_teiv_stages_gen_G_inoculum_p->n_L;
  model_teiv_stages_gen_G_inoculum_p->dim_L_0_2 = model_teiv_stages_gen_G_inoculum_p->G;
  model_teiv_stages_gen_G_inoculum_p->dim_L_0 = model_teiv_stages_gen_G_inoculum_p->dim_L_0_1 * model_teiv_stages_gen_G_inoculum_p->dim_L_0_2;
  model_teiv_stages_gen_G_inoculum_p->L_0 = (double*) Calloc(model_teiv_stages_gen_G_inoculum_p->dim_L_0, double);
  Free(model_teiv_stages_gen_G_inoculum_p->I_0);
  model_teiv_stages_gen_G_inoculum_p->dim_I_0_1 = model_teiv_stages_gen_G_inoculum_p->n_I;
  model_teiv_stages_gen_G_inoculum_p->dim_I_0_2 = model_teiv_stages_gen_G_inoculum_p->G;
  model_teiv_stages_gen_G_inoculum_p->dim_I_0 = model_teiv_stages_gen_G_inoculum_p->dim_I_0_1 * model_teiv_stages_gen_G_inoculum_p->dim_I_0_2;
  model_teiv_stages_gen_G_inoculum_p->I_0 = (double*) Calloc(model_teiv_stages_gen_G_inoculum_p->dim_I_0, double);
  model_teiv_stages_gen_G_inoculum_p->initial_T1 = model_teiv_stages_gen_G_inoculum_p->T_0;
  model_teiv_stages_gen_G_inoculum_p->initial_V[0] = model_teiv_stages_gen_G_inoculum_p->V_inf_0;
  for (int i = 1; i < model_teiv_stages_gen_G_inoculum_p->G; ++i) {
    model_teiv_stages_gen_G_inoculum_p->initial_V[i] = 0;
  }
  model_teiv_stages_gen_G_inoculum_p->initial_W[0] = model_teiv_stages_gen_G_inoculum_p->V_inf_0;
  for (int i = 1; i < model_teiv_stages_gen_G_inoculum_p->G; ++i) {
    model_teiv_stages_gen_G_inoculum_p->initial_W[i] = 0;
  }
  get_user_array(user, "L_0", true, model_teiv_stages_gen_G_inoculum_p->L_0, 2, model_teiv_stages_gen_G_inoculum_p->dim_L_0_1, model_teiv_stages_gen_G_inoculum_p->dim_L_0_2);
  for (int i = 0; i < model_teiv_stages_gen_G_inoculum_p->n_L; ++i) {
    for (int j = 0; j < model_teiv_stages_gen_G_inoculum_p->G; ++j) {
      model_teiv_stages_gen_G_inoculum_p->initial_L[i + j * model_teiv_stages_gen_G_inoculum_p->dim_L_1] = model_teiv_stages_gen_G_inoculum_p->L_0[i + j * model_teiv_stages_gen_G_inoculum_p->dim_L_0_1];
    }
  }
  get_user_array(user, "I_0", true, model_teiv_stages_gen_G_inoculum_p->I_0, 2, model_teiv_stages_gen_G_inoculum_p->dim_I_0_1, model_teiv_stages_gen_G_inoculum_p->dim_I_0_2);
  for (int i = 0; i < model_teiv_stages_gen_G_inoculum_p->n_I; ++i) {
    for (int j = 0; j < model_teiv_stages_gen_G_inoculum_p->G; ++j) {
      model_teiv_stages_gen_G_inoculum_p->initial_I[i + j * model_teiv_stages_gen_G_inoculum_p->dim_I_1] = model_teiv_stages_gen_G_inoculum_p->I_0[i + j * model_teiv_stages_gen_G_inoculum_p->dim_I_0_1];
    }
  }
  model_teiv_stages_gen_G_inoculum_p->dim = model_teiv_stages_gen_G_inoculum_p->offset_W + model_teiv_stages_gen_G_inoculum_p->dim_W;
  return R_NilValue;
}
// Wrapper around this for use from R.
SEXP r_model_teiv_stages_gen_G_inoculum_set_user(SEXP model_teiv_stages_gen_G_inoculum_ptr, SEXP user) {
  model_teiv_stages_gen_G_inoculum_pars *model_teiv_stages_gen_G_inoculum_p = model_teiv_stages_gen_G_inoculum_get_pointer(model_teiv_stages_gen_G_inoculum_ptr, 1);
  model_teiv_stages_gen_G_inoculum_set_user(model_teiv_stages_gen_G_inoculum_p, user);
  return R_NilValue;
}

// Arrange to free all memory we have allocated
// This is called by R automatically when the pointer is
// garbage collected (i.e., when all objects holding the pointer
// go out of scope
void model_teiv_stages_gen_G_inoculum_finalize(SEXP model_teiv_stages_gen_G_inoculum_ptr) {
  model_teiv_stages_gen_G_inoculum_pars *model_teiv_stages_gen_G_inoculum_p = model_teiv_stages_gen_G_inoculum_get_pointer(model_teiv_stages_gen_G_inoculum_ptr, 0);
  if (model_teiv_stages_gen_G_inoculum_ptr) {
    Free(model_teiv_stages_gen_G_inoculum_p->initial_L);
    Free(model_teiv_stages_gen_G_inoculum_p->initial_I);
    Free(model_teiv_stages_gen_G_inoculum_p->initial_V);
    Free(model_teiv_stages_gen_G_inoculum_p->initial_W);
    Free(model_teiv_stages_gen_G_inoculum_p->L_0);
    Free(model_teiv_stages_gen_G_inoculum_p->I_0);
    Free(model_teiv_stages_gen_G_inoculum_p);
    R_ClearExternalPtr(model_teiv_stages_gen_G_inoculum_ptr);
  }
}

SEXP model_teiv_stages_gen_G_inoculum_initialise(SEXP model_teiv_stages_gen_G_inoculum_ptr, SEXP t_ptr) {
  model_teiv_stages_gen_G_inoculum_pars *model_teiv_stages_gen_G_inoculum_p = model_teiv_stages_gen_G_inoculum_get_pointer(model_teiv_stages_gen_G_inoculum_ptr, 1);
  SEXP state = PROTECT(allocVector(REALSXP, model_teiv_stages_gen_G_inoculum_p->dim));
  REAL(state)[0] = model_teiv_stages_gen_G_inoculum_p->initial_T1;
  memcpy(REAL(state) + 1, model_teiv_stages_gen_G_inoculum_p->initial_L, model_teiv_stages_gen_G_inoculum_p->dim_L * sizeof(double));
  memcpy(REAL(state) + model_teiv_stages_gen_G_inoculum_p->offset_I, model_teiv_stages_gen_G_inoculum_p->initial_I, model_teiv_stages_gen_G_inoculum_p->dim_I * sizeof(double));
  memcpy(REAL(state) + model_teiv_stages_gen_G_inoculum_p->offset_V, model_teiv_stages_gen_G_inoculum_p->initial_V, model_teiv_stages_gen_G_inoculum_p->dim_V * sizeof(double));
  memcpy(REAL(state) + model_teiv_stages_gen_G_inoculum_p->offset_W, model_teiv_stages_gen_G_inoculum_p->initial_W, model_teiv_stages_gen_G_inoculum_p->dim_W * sizeof(double));
  UNPROTECT(1);
  return state;
}

SEXP model_teiv_stages_gen_G_inoculum_set_initial(SEXP model_teiv_stages_gen_G_inoculum_ptr, SEXP t_ptr, SEXP state_ptr) {
  return R_NilValue;
}

void model_teiv_stages_gen_G_inoculum_deriv(model_teiv_stages_gen_G_inoculum_pars *model_teiv_stages_gen_G_inoculum_p, double t, double *state, double *dstatedt, double *output) {
  double T1 = state[0];
  double *L = state + 1;
  double *I = state + model_teiv_stages_gen_G_inoculum_p->offset_I;
  double *V = state + model_teiv_stages_gen_G_inoculum_p->offset_V;
  double *deriv_L = dstatedt + 1;
  double *deriv_I = dstatedt + model_teiv_stages_gen_G_inoculum_p->offset_I;
  double *deriv_V = dstatedt + model_teiv_stages_gen_G_inoculum_p->offset_V;
  double *deriv_W = dstatedt + model_teiv_stages_gen_G_inoculum_p->offset_W;
  dstatedt[0] = -model_teiv_stages_gen_G_inoculum_p->beta * T1 * odin_sum1(V, 0, model_teiv_stages_gen_G_inoculum_p->dim_V - 1);
  {
    int i = 0;
    for (int j = 0; j < model_teiv_stages_gen_G_inoculum_p->G; ++j) {
      deriv_L[i + j * model_teiv_stages_gen_G_inoculum_p->dim_L_1] = model_teiv_stages_gen_G_inoculum_p->beta * T1 * V[j] - model_teiv_stages_gen_G_inoculum_p->k1 * model_teiv_stages_gen_G_inoculum_p->n_L * L[0 + j * model_teiv_stages_gen_G_inoculum_p->dim_L_1];
    }
  }
  for (int i = 1; i < model_teiv_stages_gen_G_inoculum_p->n_L; ++i) {
    for (int j = 0; j < model_teiv_stages_gen_G_inoculum_p->G; ++j) {
      deriv_L[i + j * model_teiv_stages_gen_G_inoculum_p->dim_L_1] = model_teiv_stages_gen_G_inoculum_p->k1 * model_teiv_stages_gen_G_inoculum_p->n_L * (L[i - 1 + j * model_teiv_stages_gen_G_inoculum_p->dim_L_1] - L[i + j * model_teiv_stages_gen_G_inoculum_p->dim_L_1]);
    }
  }
  {
    int i = 0;
    for (int j = 0; j < model_teiv_stages_gen_G_inoculum_p->G; ++j) {
      deriv_I[i + j * model_teiv_stages_gen_G_inoculum_p->dim_I_1] = model_teiv_stages_gen_G_inoculum_p->k1 * model_teiv_stages_gen_G_inoculum_p->n_L * L[model_teiv_stages_gen_G_inoculum_p->n_L - 1 + j * model_teiv_stages_gen_G_inoculum_p->dim_L_1] - model_teiv_stages_gen_G_inoculum_p->delta * model_teiv_stages_gen_G_inoculum_p->n_I * I[0 + j * model_teiv_stages_gen_G_inoculum_p->dim_I_1];
    }
  }
  for (int i = 1; i < model_teiv_stages_gen_G_inoculum_p->n_I; ++i) {
    for (int j = 0; j < model_teiv_stages_gen_G_inoculum_p->G; ++j) {
      deriv_I[i + j * model_teiv_stages_gen_G_inoculum_p->dim_I_1] = model_teiv_stages_gen_G_inoculum_p->delta * model_teiv_stages_gen_G_inoculum_p->n_I * (I[i - 1 + j * model_teiv_stages_gen_G_inoculum_p->dim_I_1] - I[i + j * model_teiv_stages_gen_G_inoculum_p->dim_I_1]);
    }
  }
  {
    int i = 0;
    deriv_V[i] = -(model_teiv_stages_gen_G_inoculum_p->c_inf + model_teiv_stages_gen_G_inoculum_p->beta_inf * T1) * V[0];
  }
  for (int i = 1; i < model_teiv_stages_gen_G_inoculum_p->G - 1; ++i) {
    deriv_V[i] = model_teiv_stages_gen_G_inoculum_p->p_inf * odin_sum2(I, 0, model_teiv_stages_gen_G_inoculum_p->dim_I_1 - 1, i - 1, i - 1, model_teiv_stages_gen_G_inoculum_p->dim_I_1) - (model_teiv_stages_gen_G_inoculum_p->c_inf + model_teiv_stages_gen_G_inoculum_p->beta_inf * T1) * V[i];
  }
  {
    int i = model_teiv_stages_gen_G_inoculum_p->G - 1;
    deriv_V[i] = model_teiv_stages_gen_G_inoculum_p->p_inf * (odin_sum2(I, 0, model_teiv_stages_gen_G_inoculum_p->dim_I_1 - 1, model_teiv_stages_gen_G_inoculum_p->G - 2, model_teiv_stages_gen_G_inoculum_p->G - 2, model_teiv_stages_gen_G_inoculum_p->dim_I_1) + odin_sum2(I, 0, model_teiv_stages_gen_G_inoculum_p->dim_I_1 - 1, model_teiv_stages_gen_G_inoculum_p->G - 1, model_teiv_stages_gen_G_inoculum_p->G - 1, model_teiv_stages_gen_G_inoculum_p->dim_I_1)) - (model_teiv_stages_gen_G_inoculum_p->c_inf + model_teiv_stages_gen_G_inoculum_p->beta_inf * T1) * V[model_teiv_stages_gen_G_inoculum_p->G - 1];
  }
  {
    int i = 0;
    deriv_W[i] = 0;
  }
  for (int i = 1; i < model_teiv_stages_gen_G_inoculum_p->G - 1; ++i) {
    deriv_W[i] = model_teiv_stages_gen_G_inoculum_p->p_inf * odin_sum2(I, 0, model_teiv_stages_gen_G_inoculum_p->dim_I_1 - 1, i - 1, i - 1, model_teiv_stages_gen_G_inoculum_p->dim_I_1);
  }
  {
    int i = model_teiv_stages_gen_G_inoculum_p->G - 1;
    deriv_W[i] = model_teiv_stages_gen_G_inoculum_p->p_inf * (odin_sum2(I, 0, model_teiv_stages_gen_G_inoculum_p->dim_I_1 - 1, model_teiv_stages_gen_G_inoculum_p->G - 2, model_teiv_stages_gen_G_inoculum_p->G - 2, model_teiv_stages_gen_G_inoculum_p->dim_I_1) + odin_sum2(I, 0, model_teiv_stages_gen_G_inoculum_p->dim_I_1 - 1, model_teiv_stages_gen_G_inoculum_p->G - 1, model_teiv_stages_gen_G_inoculum_p->G - 1, model_teiv_stages_gen_G_inoculum_p->dim_I_1));
  }
}

// deSolve interface
// Global variable set on initmod, as per deSolve design
static model_teiv_stages_gen_G_inoculum_pars *model_teiv_stages_gen_G_inoculum_p;
void model_teiv_stages_gen_G_inoculum_initmod_ds(void(* odeparms) (int *, double *)) {
  DL_FUNC get_deSolve_gparms = R_GetCCallable("deSolve", "get_deSolve_gparms");
  model_teiv_stages_gen_G_inoculum_p = model_teiv_stages_gen_G_inoculum_get_pointer(get_deSolve_gparms(), 1);
}
void model_teiv_stages_gen_G_inoculum_deriv_ds(int *neq, double *t, double *state,
                                               double *dstatedt, double *output, int *np) {
  model_teiv_stages_gen_G_inoculum_deriv(model_teiv_stages_gen_G_inoculum_p, *t, state, dstatedt, output);
}

// dde interface
void model_teiv_stages_gen_G_inoculum_deriv_dde(size_t n_eq, double t, double *state,
                                                 double *dstatedt, void *model_teiv_stages_gen_G_inoculum_p) {
  model_teiv_stages_gen_G_inoculum_deriv((model_teiv_stages_gen_G_inoculum_pars*)model_teiv_stages_gen_G_inoculum_p, t, state, dstatedt, NULL);
}

SEXP model_teiv_stages_gen_G_inoculum_deriv_r(SEXP model_teiv_stages_gen_G_inoculum_ptr, SEXP t, SEXP state) {
  SEXP dstatedt = PROTECT(allocVector(REALSXP, LENGTH(state)));
  model_teiv_stages_gen_G_inoculum_pars *model_teiv_stages_gen_G_inoculum_p = model_teiv_stages_gen_G_inoculum_get_pointer(model_teiv_stages_gen_G_inoculum_ptr, 1);
  double *output = NULL;
  model_teiv_stages_gen_G_inoculum_deriv(model_teiv_stages_gen_G_inoculum_p, REAL(t)[0], REAL(state), REAL(dstatedt), output);
  UNPROTECT(1);
  return dstatedt;
}

// Translate all elements in the struct back to R
// This will mostly be useful for debugging.
SEXP model_teiv_stages_gen_G_inoculum_contents(SEXP model_teiv_stages_gen_G_inoculum_ptr) {
  model_teiv_stages_gen_G_inoculum_pars *model_teiv_stages_gen_G_inoculum_p = model_teiv_stages_gen_G_inoculum_get_pointer(model_teiv_stages_gen_G_inoculum_ptr, 1);
  SEXP state = PROTECT(allocVector(VECSXP, 38));
  SET_VECTOR_ELT(state, 0, ScalarInteger(model_teiv_stages_gen_G_inoculum_p->odin_use_dde));
  SET_VECTOR_ELT(state, 1, ScalarInteger(model_teiv_stages_gen_G_inoculum_p->n_L));
  SET_VECTOR_ELT(state, 2, ScalarInteger(model_teiv_stages_gen_G_inoculum_p->n_I));
  SET_VECTOR_ELT(state, 3, ScalarReal(model_teiv_stages_gen_G_inoculum_p->beta));
  SET_VECTOR_ELT(state, 4, ScalarReal(model_teiv_stages_gen_G_inoculum_p->beta_inf));
  SET_VECTOR_ELT(state, 5, ScalarReal(model_teiv_stages_gen_G_inoculum_p->delta));
  SET_VECTOR_ELT(state, 6, ScalarReal(model_teiv_stages_gen_G_inoculum_p->p_inf));
  SET_VECTOR_ELT(state, 7, ScalarReal(model_teiv_stages_gen_G_inoculum_p->c_inf));
  SET_VECTOR_ELT(state, 8, ScalarReal(model_teiv_stages_gen_G_inoculum_p->T_0));
  SET_VECTOR_ELT(state, 9, ScalarReal(model_teiv_stages_gen_G_inoculum_p->V_inf_0));
  SET_VECTOR_ELT(state, 10, ScalarInteger(model_teiv_stages_gen_G_inoculum_p->G));
  SET_VECTOR_ELT(state, 11, ScalarReal(model_teiv_stages_gen_G_inoculum_p->k1));
  SET_VECTOR_ELT(state, 12, ScalarInteger(model_teiv_stages_gen_G_inoculum_p->dim_L));
  SET_VECTOR_ELT(state, 13, ScalarInteger(model_teiv_stages_gen_G_inoculum_p->dim_L_1));
  SET_VECTOR_ELT(state, 14, ScalarInteger(model_teiv_stages_gen_G_inoculum_p->dim_L_2));
  SET_VECTOR_ELT(state, 15, allocVector(REALSXP, model_teiv_stages_gen_G_inoculum_p->dim_L));
  memcpy(REAL(VECTOR_ELT(state, 15)), model_teiv_stages_gen_G_inoculum_p->initial_L, model_teiv_stages_gen_G_inoculum_p->dim_L * sizeof(double));
  odin_set_dim(VECTOR_ELT(state, 15), 2, model_teiv_stages_gen_G_inoculum_p->dim_L_1, model_teiv_stages_gen_G_inoculum_p->dim_L_2);
  SET_VECTOR_ELT(state, 16, ScalarInteger(model_teiv_stages_gen_G_inoculum_p->offset_L));
  SET_VECTOR_ELT(state, 17, ScalarInteger(model_teiv_stages_gen_G_inoculum_p->dim_I));
  SET_VECTOR_ELT(state, 18, ScalarInteger(model_teiv_stages_gen_G_inoculum_p->dim_I_1));
  SET_VECTOR_ELT(state, 19, ScalarInteger(model_teiv_stages_gen_G_inoculum_p->dim_I_2));
  SET_VECTOR_ELT(state, 20, allocVector(REALSXP, model_teiv_stages_gen_G_inoculum_p->dim_I));
  memcpy(REAL(VECTOR_ELT(state, 20)), model_teiv_stages_gen_G_inoculum_p->initial_I, model_teiv_stages_gen_G_inoculum_p->dim_I * sizeof(double));
  odin_set_dim(VECTOR_ELT(state, 20), 2, model_teiv_stages_gen_G_inoculum_p->dim_I_1, model_teiv_stages_gen_G_inoculum_p->dim_I_2);
  SET_VECTOR_ELT(state, 21, ScalarInteger(model_teiv_stages_gen_G_inoculum_p->offset_I));
  SET_VECTOR_ELT(state, 22, ScalarInteger(model_teiv_stages_gen_G_inoculum_p->dim_V));
  SET_VECTOR_ELT(state, 23, allocVector(REALSXP, model_teiv_stages_gen_G_inoculum_p->dim_V));
  memcpy(REAL(VECTOR_ELT(state, 23)), model_teiv_stages_gen_G_inoculum_p->initial_V, model_teiv_stages_gen_G_inoculum_p->dim_V * sizeof(double));
  SET_VECTOR_ELT(state, 24, ScalarInteger(model_teiv_stages_gen_G_inoculum_p->offset_V));
  SET_VECTOR_ELT(state, 25, ScalarInteger(model_teiv_stages_gen_G_inoculum_p->dim_W));
  SET_VECTOR_ELT(state, 26, allocVector(REALSXP, model_teiv_stages_gen_G_inoculum_p->dim_W));
  memcpy(REAL(VECTOR_ELT(state, 26)), model_teiv_stages_gen_G_inoculum_p->initial_W, model_teiv_stages_gen_G_inoculum_p->dim_W * sizeof(double));
  SET_VECTOR_ELT(state, 27, ScalarInteger(model_teiv_stages_gen_G_inoculum_p->offset_W));
  SET_VECTOR_ELT(state, 28, ScalarInteger(model_teiv_stages_gen_G_inoculum_p->dim_L_0));
  SET_VECTOR_ELT(state, 29, ScalarInteger(model_teiv_stages_gen_G_inoculum_p->dim_L_0_1));
  SET_VECTOR_ELT(state, 30, ScalarInteger(model_teiv_stages_gen_G_inoculum_p->dim_L_0_2));
  SET_VECTOR_ELT(state, 31, allocVector(REALSXP, model_teiv_stages_gen_G_inoculum_p->dim_L_0));
  memcpy(REAL(VECTOR_ELT(state, 31)), model_teiv_stages_gen_G_inoculum_p->L_0, model_teiv_stages_gen_G_inoculum_p->dim_L_0 * sizeof(double));
  odin_set_dim(VECTOR_ELT(state, 31), 2, model_teiv_stages_gen_G_inoculum_p->dim_L_0_1, model_teiv_stages_gen_G_inoculum_p->dim_L_0_2);
  SET_VECTOR_ELT(state, 32, ScalarInteger(model_teiv_stages_gen_G_inoculum_p->dim_I_0));
  SET_VECTOR_ELT(state, 33, ScalarInteger(model_teiv_stages_gen_G_inoculum_p->dim_I_0_1));
  SET_VECTOR_ELT(state, 34, ScalarInteger(model_teiv_stages_gen_G_inoculum_p->dim_I_0_2));
  SET_VECTOR_ELT(state, 35, allocVector(REALSXP, model_teiv_stages_gen_G_inoculum_p->dim_I_0));
  memcpy(REAL(VECTOR_ELT(state, 35)), model_teiv_stages_gen_G_inoculum_p->I_0, model_teiv_stages_gen_G_inoculum_p->dim_I_0 * sizeof(double));
  odin_set_dim(VECTOR_ELT(state, 35), 2, model_teiv_stages_gen_G_inoculum_p->dim_I_0_1, model_teiv_stages_gen_G_inoculum_p->dim_I_0_2);
  SET_VECTOR_ELT(state, 36, ScalarReal(model_teiv_stages_gen_G_inoculum_p->initial_T1));
  SET_VECTOR_ELT(state, 37, ScalarInteger(model_teiv_stages_gen_G_inoculum_p->dim));
  SEXP state_names = PROTECT(allocVector(STRSXP, 38));
  SET_STRING_ELT(state_names, 0, mkChar("odin_use_dde"));
  SET_STRING_ELT(state_names, 1, mkChar("n_L"));
  SET_STRING_ELT(state_names, 2, mkChar("n_I"));
  SET_STRING_ELT(state_names, 3, mkChar("beta"));
  SET_STRING_ELT(state_names, 4, mkChar("beta_inf"));
  SET_STRING_ELT(state_names, 5, mkChar("delta"));
  SET_STRING_ELT(state_names, 6, mkChar("p_inf"));
  SET_STRING_ELT(state_names, 7, mkChar("c_inf"));
  SET_STRING_ELT(state_names, 8, mkChar("T_0"));
  SET_STRING_ELT(state_names, 9, mkChar("V_inf_0"));
  SET_STRING_ELT(state_names, 10, mkChar("G"));
  SET_STRING_ELT(state_names, 11, mkChar("k1"));
  SET_STRING_ELT(state_names, 12, mkChar("dim_L"));
  SET_STRING_ELT(state_names, 13, mkChar("dim_L_1"));
  SET_STRING_ELT(state_names, 14, mkChar("dim_L_2"));
  SET_STRING_ELT(state_names, 15, mkChar("initial_L"));
  SET_STRING_ELT(state_names, 16, mkChar("offset_L"));
  SET_STRING_ELT(state_names, 17, mkChar("dim_I"));
  SET_STRING_ELT(state_names, 18, mkChar("dim_I_1"));
  SET_STRING_ELT(state_names, 19, mkChar("dim_I_2"));
  SET_STRING_ELT(state_names, 20, mkChar("initial_I"));
  SET_STRING_ELT(state_names, 21, mkChar("offset_I"));
  SET_STRING_ELT(state_names, 22, mkChar("dim_V"));
  SET_STRING_ELT(state_names, 23, mkChar("initial_V"));
  SET_STRING_ELT(state_names, 24, mkChar("offset_V"));
  SET_STRING_ELT(state_names, 25, mkChar("dim_W"));
  SET_STRING_ELT(state_names, 26, mkChar("initial_W"));
  SET_STRING_ELT(state_names, 27, mkChar("offset_W"));
  SET_STRING_ELT(state_names, 28, mkChar("dim_L_0"));
  SET_STRING_ELT(state_names, 29, mkChar("dim_L_0_1"));
  SET_STRING_ELT(state_names, 30, mkChar("dim_L_0_2"));
  SET_STRING_ELT(state_names, 31, mkChar("L_0"));
  SET_STRING_ELT(state_names, 32, mkChar("dim_I_0"));
  SET_STRING_ELT(state_names, 33, mkChar("dim_I_0_1"));
  SET_STRING_ELT(state_names, 34, mkChar("dim_I_0_2"));
  SET_STRING_ELT(state_names, 35, mkChar("I_0"));
  SET_STRING_ELT(state_names, 36, mkChar("initial_T1"));
  SET_STRING_ELT(state_names, 37, mkChar("dim"));
  setAttrib(state, R_NamesSymbol, state_names);
  UNPROTECT(2);
  return state;
}

// Report back to R information on variable ordering
// The reported information includes position and length of each
// variable, from which offset, etc, can be worked out.
SEXP model_teiv_stages_gen_G_inoculum_variable_order(SEXP model_teiv_stages_gen_G_inoculum_ptr) {
  model_teiv_stages_gen_G_inoculum_pars *model_teiv_stages_gen_G_inoculum_p = model_teiv_stages_gen_G_inoculum_get_pointer(model_teiv_stages_gen_G_inoculum_ptr, 1);
  int *tmp;
  SEXP state_len = PROTECT(allocVector(VECSXP, 5));
  SEXP state_names = PROTECT(allocVector(STRSXP, 5));
  SET_VECTOR_ELT(state_len, 0, R_NilValue);
  SET_STRING_ELT(state_names, 0, mkChar("T1"));
  SET_VECTOR_ELT(state_len, 1, allocVector(INTSXP, 2));
  tmp = INTEGER(VECTOR_ELT(state_len, 1));
  tmp[0] = model_teiv_stages_gen_G_inoculum_p->dim_L_1;
  tmp[1] = model_teiv_stages_gen_G_inoculum_p->dim_L_2;
  SET_STRING_ELT(state_names, 1, mkChar("L"));
  SET_VECTOR_ELT(state_len, 2, allocVector(INTSXP, 2));
  tmp = INTEGER(VECTOR_ELT(state_len, 2));
  tmp[0] = model_teiv_stages_gen_G_inoculum_p->dim_I_1;
  tmp[1] = model_teiv_stages_gen_G_inoculum_p->dim_I_2;
  SET_STRING_ELT(state_names, 2, mkChar("I"));
  SET_VECTOR_ELT(state_len, 3, ScalarInteger(model_teiv_stages_gen_G_inoculum_p->dim_V));
  SET_STRING_ELT(state_names, 3, mkChar("V"));
  SET_VECTOR_ELT(state_len, 4, ScalarInteger(model_teiv_stages_gen_G_inoculum_p->dim_W));
  SET_STRING_ELT(state_names, 4, mkChar("W"));
  setAttrib(state_len, R_NamesSymbol, state_names);
  UNPROTECT(2);
  return state_len;
}

model_teiv_stages_gen_G_inoculum_pars* model_teiv_stages_gen_G_inoculum_get_pointer(SEXP model_teiv_stages_gen_G_inoculum_ptr, int closed_error) {
  model_teiv_stages_gen_G_inoculum_pars *model_teiv_stages_gen_G_inoculum_p = NULL;
  if (TYPEOF(model_teiv_stages_gen_G_inoculum_ptr) != EXTPTRSXP) {
    Rf_error("Expected an external pointer");
  }
  model_teiv_stages_gen_G_inoculum_p = (model_teiv_stages_gen_G_inoculum_pars*) R_ExternalPtrAddr(model_teiv_stages_gen_G_inoculum_ptr);
  if (!model_teiv_stages_gen_G_inoculum_p && closed_error) {
    Rf_error("Pointer has been invalidated");
  }
  return model_teiv_stages_gen_G_inoculum_p;
}

SEXP get_ds_pars() {
  static DL_FUNC get_deSolve_gparms = NULL;
  if (get_deSolve_gparms == NULL) {
    get_deSolve_gparms = R_GetCCallable("deSolve", "get_deSolve_gparms");
  }
  return get_deSolve_gparms();
}
double get_user_double(SEXP user, const char *name, double default_value) {
  double ret = default_value;
  SEXP el = get_list_element(user, name);
  if (el != R_NilValue) {
    if (length(el) != 1) {
      Rf_error("Expected scalar numeric for %s", name);
    }
    if (TYPEOF(el) == REALSXP) {
      ret = REAL(el)[0];
    } else if (TYPEOF(el) == INTSXP) {
      ret = INTEGER(el)[0];
    } else {
      Rf_error("Expected a numeric value for %s", name);
    }
  }
  if (ISNA(ret)) {
    Rf_error("Expected value for %s", name);
  }
  return ret;
}
SEXP get_list_element(SEXP list, const char *name) {
  SEXP ret = R_NilValue, names = getAttrib(list, R_NamesSymbol);
  for (int i = 0; i < length(list); ++i) {
    if(strcmp(CHAR(STRING_ELT(names, i)), name) == 0) {
      ret = VECTOR_ELT(list, i);
      break;
    }
  }
  return ret;
}
int get_user_int(SEXP user, const char *name, int default_value) {
  int ret = default_value;
  SEXP el = get_list_element(user, name);
  if (el != R_NilValue) {
    if (length(el) != 1) {
      Rf_error("Expected scalar integer for %d", name);
    }
    ret = INTEGER(coerceVector(el, INTSXP))[0];
  }
  if (ret == NA_INTEGER) {
    Rf_error("Expected value for %s", name);
  }
  return ret;
}
void get_user_array(SEXP user, const char *name, bool is_real, void *dest, int nd, ...) {
  SEXP el = get_user_array_check_rank(user, name, nd);
  SEXP r_dim;
  int *dim;

  if (nd == 1) {
    r_dim = PROTECT(ScalarInteger(LENGTH(el)));
  } else {
    r_dim = PROTECT(coerceVector(getAttrib(el, R_DimSymbol), INTSXP));
  }
  dim = INTEGER(r_dim);

  va_list ap;
  va_start(ap, nd);
  for (size_t i = 0; i < (size_t) nd; ++i) {
    int dim_expected = va_arg(ap, int);
    if (dim[i] != dim_expected) {
      va_end(ap); // avoid a leak
      if (nd == 1) {
        Rf_error("Expected length %d value for %s", dim_expected, name);
      } else {
        Rf_error("Incorrect size of dimension %d of %s (expected %d)",
                 i + 1, name, dim_expected);
      }
    }
  }
  va_end(ap);
  UNPROTECT(1);

  get_user_array_copy(el, name, is_real, dest);
}
SEXP get_user_array_check_rank(SEXP user, const char *name, int nd) {
  SEXP el = get_list_element(user, name);
  if (el == R_NilValue) {
    Rf_error("Expected value for %s", name);
  } else {
    if (nd == 1) {
      if (isArray(el)) {
        // this may be too strict as a length-1 dim here will fail
        Rf_error("Expected a vector for %s", name);
      }
    } else {
      SEXP r_dim = getAttrib(el, R_DimSymbol);
      if (r_dim == R_NilValue || LENGTH(r_dim) != nd) {
        if (nd == 2) {
          Rf_error("Expected a matrix for %s", name);
        } else {
          Rf_error("Expected a %dd array for %s", nd, name);
        }
      }
    }
  }
  return el;
}
void get_user_array_copy(SEXP el, const char *name, bool is_real, void *dest) {
  int given_int = TYPEOF(el) == INTSXP;
  size_t n = (size_t) length(el);
  if (is_real) {
    if (given_int) {
      el = PROTECT(coerceVector(el, REALSXP));
    } else if (TYPEOF(el) != REALSXP) {
      Rf_error("Expected a numeric value for %s", name);
    }
    memcpy(dest, REAL(el), n * sizeof(double));
  } else {
    if (TYPEOF(el) == REALSXP) {
      el = PROTECT(coerceVector(el, INTSXP));
    } else if (TYPEOF(el) != INTSXP) {
      Rf_error("Expected a numeric value for %s", name);
    }
    memcpy(dest, INTEGER(el), n * sizeof(int));
  }
  if (given_int == is_real) {
    UNPROTECT(1);
  }
}
double odin_sum1(double *x, int from_i, int to_i) {
  double tot = 0.0;
  for (int i = from_i; i <= to_i; ++i) {
    tot += x[i];
  }
  return tot;
}
void odin_set_dim(SEXP target, int nd, ...) {
  SEXP r_dim = PROTECT(allocVector(INTSXP, nd));
  int *dim = INTEGER(r_dim);

  va_list ap;
  va_start(ap, nd);
  for (size_t i = 0; i < (size_t)nd; ++i) {
    dim[i] = va_arg(ap, int);
  }
  va_end(ap);

  setAttrib(target, R_DimSymbol, r_dim);
  UNPROTECT(1);
}
double odin_sum2(double *x, int from_i, int to_i, int from_j, int to_j, int dim_x_1) {
  double tot = 0.0;
  for (int j = from_j; j <= to_j; ++j) {
    int jj = j * dim_x_1;
    for (int i = from_i; i <= to_i; ++i) {
      tot += x[i + jj];
    }
  }
  return tot;
}
